import { Observable, ReplaySubject } from 'rxjs';
import { LocalDatabase } from './local-database';
export declare class IndexedDBDatabase implements LocalDatabase {
    /**
     * `indexedDB` database name
     */
    protected readonly dbName: string;
    /**
     * `indexedDB` object store name
     */
    protected readonly storeName: string;
    /**
     * `indexedDB` database version. Must be an unsigned **integer**
     */
    protected readonly dbVersion: number;
    /**
     * `indexedDB` database connection, wrapped in a RxJS `ReplaySubject` to be able to access the connection
     * even after the connection success event happened
     */
    protected readonly database: ReplaySubject<IDBDatabase>;
    /**
     * Flag to not wrap `indexedDB` values for interoperability or to wrap for backward compatibility.
     */
    protected readonly noWrap: boolean;
    /**
     * Index used when wrapping value. *For backward compatibility only.*
     */
    protected readonly wrapIndex = "value";
    /**
     * Constructor params are provided by Angular (but can also be passed manually in tests)
     * @param dbName `indexedDB` database name
     * @param storeName `indexedDB` store name
     * @param dbVersion `indexedDB` database version
     * @param noWrap `indexedDB` database version
     * @param oldPrefix Pre-v8 backward compatible prefix
     */
    constructor(dbName?: string, storeName?: string, dbVersion?: number, noWrap?: boolean, oldPrefix?: string);
    /**
     * Information about `indexedDB` connection. *Only useful for interoperability.*
     * @returns `indexedDB` database name, store name and database version
     */
    readonly backingStore: {
        database: string;
        store: string;
        version: number;
    };
    /**
     * Number of items in our `indexedDB` database and object store
     */
    readonly size: Observable<number>;
    /**
     * Gets an item value in our `indexedDB` store
     * @param key The item's key
     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in an RxJS `Observable`
     */
    get<T = any>(key: string): Observable<T | undefined>;
    /**
     * Sets an item in our `indexedDB` store
     * @param key The item's key
     * @param data The item's value
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    set(key: string, data: any): Observable<undefined>;
    /**
     * Deletes an item in our `indexedDB` store
     * @param key The item's key
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    delete(key: string): Observable<undefined>;
    /**
     * Deletes all items from our `indexedDB` objet store
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    clear(): Observable<undefined>;
    /**
     * Get all the keys in our `indexedDB` store
     * @returns An RxJS `Observable` iterating on each key
     */
    keys(): Observable<string>;
    /**
     * Check if a key exists in our `indexedDB` store
     * @returns An RxJS `Observable` telling if the key exists or not
     */
    has(key: string): Observable<boolean>;
    /**
     * Connects to `indexedDB` and creates the object store on first time
     */
    protected connect(): void;
    /**
     * Create store on first use of `indexedDB`
     * @param request `indexedDB` database opening request
     */
    protected createStore(request: IDBOpenDBRequest): void;
    /**
     * Open an `indexedDB` transaction and get our store
     * @param mode `readonly` or `readwrite`
     * @returns An `indexedDB` store, wrapped in an RxJS `Observable`
     */
    protected transaction(mode: IDBTransactionMode): Observable<IDBObjectStore>;
    /**
     * Listen to an `indexedDB` success error event
     * @param request Request to listen
     * @returns An RxJS `Observable` listening to the success event
     */
    protected successEvent(request: IDBRequest): Observable<Event>;
    /**
     * Listen to an `indexedDB` request error event
     * @param request Request to listen
     * @returns An RxJS `Observable` listening to the error event and if so, throwing an error
     */
    protected errorEvent(request: IDBRequest): Observable<never>;
    /**
     * Listen to an `indexedDB` request success and error event, and map to the wanted value
     * @param request Request to listen
     * @param mapCallback Callback returning the wanted value
     * @returns An RxJS `Observable` listening to request events and mapping to the wanted value
     */
    protected requestEventsAndMapTo<T>(request: IDBRequest, mapCallback: () => T): Observable<T>;
    /**
     * Check if the key exists in the store
     * @param store Objet store on which to perform the request
     * @param key Key to check
     * @returns An `indexedDB` request
     */
    protected getKeyRequest(store: IDBObjectStore, key: string): IDBRequest;
}
