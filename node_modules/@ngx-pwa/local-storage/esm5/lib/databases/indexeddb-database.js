import * as tslib_1 from "tslib";
import { Injectable, Inject } from '@angular/core';
import { ReplaySubject, fromEvent, of, throwError, race } from 'rxjs';
import { map, mergeMap, first, takeWhile, tap } from 'rxjs/operators';
import { IDBBrokenError } from './exceptions';
import { IDB_DB_NAME, IDB_STORE_NAME, DEFAULT_IDB_STORE_NAME, IDB_DB_VERSION, LOCAL_STORAGE_PREFIX, DEFAULT_IDB_DB_NAME, DEFAULT_IDB_DB_VERSION, IDB_NO_WRAP, DEFAULT_IDB_NO_WRAP } from '../tokens';
import * as i0 from "@angular/core";
import * as i1 from "../tokens";
var IndexedDBDatabase = /** @class */ (function () {
    /**
     * Constructor params are provided by Angular (but can also be passed manually in tests)
     * @param dbName `indexedDB` database name
     * @param storeName `indexedDB` store name
     * @param dbVersion `indexedDB` database version
     * @param noWrap `indexedDB` database version
     * @param oldPrefix Pre-v8 backward compatible prefix
     */
    function IndexedDBDatabase(dbName, storeName, dbVersion, noWrap, 
    // tslint:disable-next-line: deprecation
    oldPrefix) {
        if (dbName === void 0) { dbName = DEFAULT_IDB_DB_NAME; }
        if (storeName === void 0) { storeName = DEFAULT_IDB_STORE_NAME; }
        if (dbVersion === void 0) { dbVersion = DEFAULT_IDB_DB_VERSION; }
        if (noWrap === void 0) { noWrap = DEFAULT_IDB_NO_WRAP; }
        if (oldPrefix === void 0) { oldPrefix = ''; }
        /**
         * `indexedDB` database connection, wrapped in a RxJS `ReplaySubject` to be able to access the connection
         * even after the connection success event happened
         */
        this.database = new ReplaySubject(1);
        /**
         * Index used when wrapping value. *For backward compatibility only.*
         */
        this.wrapIndex = 'value';
        /* Initialize `indexedDB` database name, with prefix if provided by the user */
        this.dbName = oldPrefix ? oldPrefix + "_" + dbName : dbName;
        this.storeName = storeName;
        this.dbVersion = dbVersion;
        this.noWrap = noWrap;
        /* Connect to `indexedDB`, with prefix if provided by the user */
        this.connect();
    }
    Object.defineProperty(IndexedDBDatabase.prototype, "backingStore", {
        /**
         * Information about `indexedDB` connection. *Only useful for interoperability.*
         * @returns `indexedDB` database name, store name and database version
         */
        get: function () {
            return {
                database: this.dbName,
                store: this.storeName,
                version: this.dbVersion,
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IndexedDBDatabase.prototype, "size", {
        /**
         * Number of items in our `indexedDB` database and object store
         */
        get: function () {
            var _this = this;
            /* Open a transaction in read-only mode */
            return this.transaction('readonly').pipe(mergeMap(function (store) {
                /* Request to know the number of items */
                var request = store.count();
                /* Manage success and error events, and get the result */
                return _this.requestEventsAndMapTo(request, function () { return request.result; });
            }), 
            /* The observable will complete after the first value */
            first());
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets an item value in our `indexedDB` store
     * @param key The item's key
     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in an RxJS `Observable`
     */
    IndexedDBDatabase.prototype.get = function (key) {
        var _this = this;
        /* Open a transaction in read-only mode */
        return this.transaction('readonly').pipe(mergeMap(function (store) {
            /* Request the value with the key provided by the user */
            var request = store.get(key);
            /* Manage success and error events, and get the result */
            return _this.requestEventsAndMapTo(request, function () {
                if ((request.result !== undefined) && (request.result !== null)) {
                    /* Prior to v8, the value was wrapped in an `{ value: ...}` object */
                    if (!_this.noWrap && (typeof request.result === 'object') && (_this.wrapIndex in request.result) &&
                        (request.result[_this.wrapIndex] !== undefined) && (request.result[_this.wrapIndex] !== null)) {
                        return request.result[_this.wrapIndex];
                    }
                    else {
                        /* Cast to the wanted type */
                        return request.result;
                    }
                }
                /* Return `undefined` if the value is empty */
                return undefined;
            });
        }), 
        /* The observable will complete after the first value */
        first());
    };
    /**
     * Sets an item in our `indexedDB` store
     * @param key The item's key
     * @param data The item's value
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    IndexedDBDatabase.prototype.set = function (key, data) {
        var _this = this;
        /* Storing `undefined` in `indexedDb` can cause issues in some browsers so removing item instead */
        if (data === undefined) {
            return this.delete(key);
        }
        /* Open a transaction in write mode */
        return this.transaction('readwrite').pipe(mergeMap(function (store) {
            /* Check if the key already exists or not
             * `getKey()` is better but only available in `indexedDB` v2 (Chrome >= 58, missing in IE/Edge).
             * In older browsers, the value is checked instead, but it could lead to an exception
             * if `undefined` was stored outside of this lib (e.g. directly with the native `indexedDB` API).
             */
            var requestGet = _this.getKeyRequest(store, key);
            /* Manage success and error events, and get the request result */
            return _this.requestEventsAndMapTo(requestGet, function () { return requestGet.result; }).pipe(mergeMap(function (existingEntry) {
                /* It is very important the second request is done from the same transaction/store as the previous one,
                 * otherwise it could lead to concurrency failures
                 * Avoid https://github.com/cyrilletuzi/angular-async-local-storage/issues/47 */
                var _a;
                /* Prior to v8, data was wrapped in a `{ value: ... }` object */
                var dataToStore = _this.noWrap ? data : (_a = {}, _a[_this.wrapIndex] = data, _a);
                /* Add if the item is not existing yet, or update otherwise */
                var requestSet = (existingEntry === undefined) ?
                    store.add(dataToStore, key) :
                    store.put(dataToStore, key);
                /* Manage success and error events, and map to `true` */
                return _this.requestEventsAndMapTo(requestSet, function () { return undefined; });
            }));
        }), 
        /* The observable will complete after the first value */
        first());
    };
    /**
     * Deletes an item in our `indexedDB` store
     * @param key The item's key
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    IndexedDBDatabase.prototype.delete = function (key) {
        var _this = this;
        /* Open a transaction in write mode */
        return this.transaction('readwrite').pipe(mergeMap(function (store) {
            /* Deletethe item in store */
            var request = store.delete(key);
            /* Manage success and error events, and map to `true` */
            return _this.requestEventsAndMapTo(request, function () { return undefined; });
        }), 
        /* The observable will complete after the first value */
        first());
    };
    /**
     * Deletes all items from our `indexedDB` objet store
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    IndexedDBDatabase.prototype.clear = function () {
        var _this = this;
        /* Open a transaction in write mode */
        return this.transaction('readwrite').pipe(mergeMap(function (store) {
            /* Delete all items in object store */
            var request = store.clear();
            /* Manage success and error events, and map to `true` */
            return _this.requestEventsAndMapTo(request, function () { return undefined; });
        }), 
        /* The observable will complete */
        first());
    };
    /**
     * Get all the keys in our `indexedDB` store
     * @returns An RxJS `Observable` iterating on each key
     */
    IndexedDBDatabase.prototype.keys = function () {
        var _this = this;
        /* Open a transaction in read-only mode */
        return this.transaction('readonly').pipe(
        /* `first()` is used as the final operator in other methods to complete the `Observable`
         * (as it all starts from a `ReplaySubject` which never ends),
         * but as this method is iterating over multiple values, `first()` **must** be used here */
        first(), mergeMap(function (store) {
            /* Open a cursor on the store
             * `.openKeyCursor()` is better for performance, but only available in indexedDB v2 (missing in IE/Edge)
             * Avoid issues like https://github.com/cyrilletuzi/angular-async-local-storage/issues/69 */
            var request = ('openKeyCursor' in store) ? store.openKeyCursor() : store.openCursor();
            /* Listen to success event */
            var success$ = _this.successEvent(request).pipe(
            /* Stop the `Observable` when the cursor is `null` */
            takeWhile(function () { return (request.result !== null); }), 
            /* This lib only allows string keys, but user could have added other types of keys from outside
             * It's OK to cast as the cursor as been tested in the previous operator */
            map(function () { return request.result.key.toString(); }), 
            /* Iterate on the cursor */
            tap(function () { request.result.continue(); }));
            /* Listen to error event and if so, throw an error */
            var error$ = _this.errorEvent(request);
            /* Choose the first event to occur */
            return race([success$, error$]);
        }));
    };
    /**
     * Check if a key exists in our `indexedDB` store
     * @returns An RxJS `Observable` telling if the key exists or not
     */
    IndexedDBDatabase.prototype.has = function (key) {
        var _this = this;
        /* Open a transaction in read-only mode */
        return this.transaction('readonly').pipe(mergeMap(function (store) {
            /* Check if the key exists in the store */
            var request = _this.getKeyRequest(store, key);
            /* Manage success and error events, and map to a boolean based on the existence of the key */
            return _this.requestEventsAndMapTo(request, function () { return (request.result !== undefined) ? true : false; });
        }), 
        /* The observable will complete */
        first());
    };
    /**
     * Connects to `indexedDB` and creates the object store on first time
     */
    IndexedDBDatabase.prototype.connect = function () {
        var _this = this;
        var request;
        /* Connect to `indexedDB`
         * Will fail in Safari cross-origin iframes
         * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42} */
        try {
            /* Do NOT explicit `window` here, as `indexedDB` could be used from a web worker too */
            request = indexedDB.open(this.dbName, this.dbVersion);
        }
        catch (_a) {
            this.database.error(new IDBBrokenError());
            return;
        }
        /* Create store on first connection */
        this.createStore(request);
        /* Listen to success and error events and choose the first to occur */
        race([this.successEvent(request), this.errorEvent(request)])
            /* The observable will complete */
            .pipe(first())
            .subscribe({
            next: function () {
                /* Register the database connection in the `ReplaySubject` for further access */
                _this.database.next(request.result);
            },
            error: function () {
                /* Firefox private mode issue: fallback storage if IndexedDb connection is failing
                * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}
                * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/26} */
                _this.database.error(new IDBBrokenError());
            },
        });
    };
    /**
     * Create store on first use of `indexedDB`
     * @param request `indexedDB` database opening request
     */
    IndexedDBDatabase.prototype.createStore = function (request) {
        var _this = this;
        /* Listen to the event fired on first connection */
        fromEvent(request, 'upgradeneeded')
            /* The observable will complete */
            .pipe(first())
            .subscribe({
            next: function () {
                /* Check if the store already exists, to avoid error */
                if (!request.result.objectStoreNames.contains(_this.storeName)) {
                    /* Create the object store */
                    request.result.createObjectStore(_this.storeName);
                }
            }
        });
    };
    /**
     * Open an `indexedDB` transaction and get our store
     * @param mode `readonly` or `readwrite`
     * @returns An `indexedDB` store, wrapped in an RxJS `Observable`
     */
    IndexedDBDatabase.prototype.transaction = function (mode) {
        var _this = this;
        /* From the `indexedDB` connection, open a transaction and get the store */
        return this.database
            .pipe(mergeMap(function (database) {
            var store;
            try {
                store = database.transaction([_this.storeName], mode).objectStore(_this.storeName);
            }
            catch (error) {
                /* The store could have been deleted from outside */
                return throwError(error);
            }
            return of(store);
        }));
    };
    /**
     * Listen to an `indexedDB` success error event
     * @param request Request to listen
     * @returns An RxJS `Observable` listening to the success event
     */
    IndexedDBDatabase.prototype.successEvent = function (request) {
        return fromEvent(request, 'success');
    };
    /**
     * Listen to an `indexedDB` request error event
     * @param request Request to listen
     * @returns An RxJS `Observable` listening to the error event and if so, throwing an error
     */
    IndexedDBDatabase.prototype.errorEvent = function (request) {
        return fromEvent(request, 'error').pipe(mergeMap(function () { return throwError(request.error); }));
    };
    /**
     * Listen to an `indexedDB` request success and error event, and map to the wanted value
     * @param request Request to listen
     * @param mapCallback Callback returning the wanted value
     * @returns An RxJS `Observable` listening to request events and mapping to the wanted value
     */
    IndexedDBDatabase.prototype.requestEventsAndMapTo = function (request, mapCallback) {
        /* Listen to the success event and map to the wanted value
         * `mapTo()` must not be used here as it would eval `request.result` too soon */
        var success$ = this.successEvent(request).pipe(map(mapCallback));
        /* Listen to the error event */
        var error$ = this.errorEvent(request);
        /* Choose the first event to occur */
        return race([success$, error$]);
    };
    /**
     * Check if the key exists in the store
     * @param store Objet store on which to perform the request
     * @param key Key to check
     * @returns An `indexedDB` request
     */
    IndexedDBDatabase.prototype.getKeyRequest = function (store, key) {
        /* `getKey()` is better but only available in `indexedDB` v2 (Chrome >= 58, missing in IE/Edge).
         * In older browsers, the value is checked instead, but it could lead to an exception
         * if `undefined` was stored outside of this lib (e.g. directly with the native `indexedDB` API).
         * Fixes https://github.com/cyrilletuzi/angular-async-local-storage/issues/69
         */
        return ('getKey' in store) ? store.getKey(key) : store.get(key);
    };
    IndexedDBDatabase.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function IndexedDBDatabase_Factory() { return new IndexedDBDatabase(i0.ɵɵinject(i1.IDB_DB_NAME), i0.ɵɵinject(i1.IDB_STORE_NAME), i0.ɵɵinject(i1.IDB_DB_VERSION), i0.ɵɵinject(i1.IDB_NO_WRAP), i0.ɵɵinject(i1.LOCAL_STORAGE_PREFIX)); }, token: IndexedDBDatabase, providedIn: "root" });
    IndexedDBDatabase = tslib_1.__decorate([
        Injectable({
            providedIn: 'root'
        }),
        tslib_1.__param(0, Inject(IDB_DB_NAME)),
        tslib_1.__param(1, Inject(IDB_STORE_NAME)),
        tslib_1.__param(2, Inject(IDB_DB_VERSION)),
        tslib_1.__param(3, Inject(IDB_NO_WRAP)),
        tslib_1.__param(4, Inject(LOCAL_STORAGE_PREFIX)),
        tslib_1.__metadata("design:paramtypes", [Object, Object, Object, Object, Object])
    ], IndexedDBDatabase);
    return IndexedDBDatabase;
}());
export { IndexedDBDatabase };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXhlZGRiLWRhdGFiYXNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neC1wd2EvbG9jYWwtc3RvcmFnZS8iLCJzb3VyY2VzIjpbImxpYi9kYXRhYmFzZXMvaW5kZXhlZGRiLWRhdGFiYXNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBQWMsYUFBYSxFQUFFLFNBQVMsRUFBRSxFQUFFLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNsRixPQUFPLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBR3RFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDOUMsT0FBTyxFQUNMLFdBQVcsRUFBRSxjQUFjLEVBQUUsc0JBQXNCLEVBQUUsY0FBYyxFQUFFLG9CQUFvQixFQUN6RixtQkFBbUIsRUFBRSxzQkFBc0IsRUFBRSxXQUFXLEVBQUUsbUJBQW1CLEVBQzlFLE1BQU0sV0FBVyxDQUFDOzs7QUFLbkI7SUFpQ0U7Ozs7Ozs7T0FPRztJQUNILDJCQUN1QixNQUE0QixFQUN6QixTQUFrQyxFQUNsQyxTQUFrQyxFQUNyQyxNQUE0QjtJQUNqRCx3Q0FBd0M7SUFDVixTQUFjO1FBTHZCLHVCQUFBLEVBQUEsNEJBQTRCO1FBQ3pCLDBCQUFBLEVBQUEsa0NBQWtDO1FBQ2xDLDBCQUFBLEVBQUEsa0NBQWtDO1FBQ3JDLHVCQUFBLEVBQUEsNEJBQTRCO1FBRW5CLDBCQUFBLEVBQUEsY0FBYztRQTlCOUM7OztXQUdHO1FBQ2dCLGFBQVEsR0FBRyxJQUFJLGFBQWEsQ0FBYyxDQUFDLENBQUMsQ0FBQztRQU9oRTs7V0FFRztRQUNnQixjQUFTLEdBQUcsT0FBTyxDQUFDO1FBbUJyQywrRUFBK0U7UUFDL0UsSUFBSSxDQUFDLE1B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LGlCQUFpQixDQW1kN0I7NEJBamVEO0NBaWVDLEFBbmRELElBbWRDO1NBbmRZLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgUmVwbGF5U3ViamVjdCwgZnJvbUV2ZW50LCBvZiwgdGhyb3dFcnJvciwgcmFjZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwLCBtZXJnZU1hcCwgZmlyc3QsIHRha2VXaGlsZSwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBMb2NhbERhdGFiYXNlIH0gZnJvbSAnLi9sb2NhbC1kYXRhYmFzZSc7XG5pbXBvcnQgeyBJREJCcm9rZW5FcnJvciB9IGZyb20gJy4vZXhjZXB0aW9ucyc7XG5pbXBvcnQge1xuICBJREJfREJfTkFNRSwgSURCX1NUT1JFX05BTUUsIERFRkFVTFRfSURCX1NUT1JFX05BTUUsIElEQl9EQl9WRVJTSU9OLCBMT0NBTF9TVE9SQUdFX1BSRUZJWCxcbiAgREVGQVVMVF9JREJfREJfTkFNRSwgREVGQVVMVF9JREJfREJfVkVSU0lPTiwgSURCX05PX1dSQVAsIERFRkFVTFRfSURCX05PX1dSQVBcbn0gZnJvbSAnLi4vdG9rZW5zJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgSW5kZXhlZERCRGF0YWJhc2UgaW1wbGVtZW50cyBMb2NhbERhdGFiYXNlIHtcblxuICAvKipcbiAgICogYGluZGV4ZWREQmAgZGF0YWJhc2UgbmFtZVxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGRiTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBgaW5kZXhlZERCYCBvYmplY3Qgc3RvcmUgbmFtZVxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHN0b3JlTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBgaW5kZXhlZERCYCBkYXRhYmFzZSB2ZXJzaW9uLiBNdXN0IGJlIGFuIHVuc2lnbmVkICoqaW50ZWdlcioqXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZGJWZXJzaW9uOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIGBpbmRleGVkREJgIGRhdGFiYXNlIGNvbm5lY3Rpb24sIHdyYXBwZWQgaW4gYSBSeEpTIGBSZXBsYXlTdWJqZWN0YCB0byBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgY29ubmVjdGlvblxuICAgKiBldmVuIGFmdGVyIHRoZSBjb25uZWN0aW9uIHN1Y2Nlc3MgZXZlbnQgaGFwcGVuZWRcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBkYXRhYmFzZSA9IG5ldyBSZXBsYXlTdWJqZWN0PElEQkRhdGFiYXNlPigxKTtcblxuICAvKipcbiAgICogRmxhZyB0byBub3Qgd3JhcCBgaW5kZXhlZERCYCB2YWx1ZXMgZm9yIGludGVyb3BlcmFiaWxpdHkgb3IgdG8gd3JhcCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBub1dyYXA6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEluZGV4IHVzZWQgd2hlbiB3cmFwcGluZyB2YWx1ZS4gKkZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IG9ubHkuKlxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHdyYXBJbmRleCA9ICd2YWx1ZSc7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIHBhcmFtcyBhcmUgcHJvdmlkZWQgYnkgQW5ndWxhciAoYnV0IGNhbiBhbHNvIGJlIHBhc3NlZCBtYW51YWxseSBpbiB0ZXN0cylcbiAgICogQHBhcmFtIGRiTmFtZSBgaW5kZXhlZERCYCBkYXRhYmFzZSBuYW1lXG4gICAqIEBwYXJhbSBzdG9yZU5hbWUgYGluZGV4ZWREQmAgc3RvcmUgbmFtZVxuICAgKiBAcGFyYW0gZGJWZXJzaW9uIGBpbmRleGVkREJgIGRhdGFiYXNlIHZlcnNpb25cbiAgICogQHBhcmFtIG5vV3JhcCBgaW5kZXhlZERCYCBkYXRhYmFzZSB2ZXJzaW9uXG4gICAqIEBwYXJhbSBvbGRQcmVmaXggUHJlLXY4IGJhY2t3YXJkIGNvbXBhdGlibGUgcHJlZml4XG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KElEQl9EQl9OQU1FKSBkYk5hbWUgPSBERUZBVUxUX0lEQl9EQl9OQU1FLFxuICAgIEBJbmplY3QoSURCX1NUT1JFX05BTUUpIHN0b3JlTmFtZSA9IERFRkFVTFRfSURCX1NUT1JFX05BTUUsXG4gICAgQEluamVjdChJREJfREJfVkVSU0lPTikgZGJWZXJzaW9uID0gREVGQVVMVF9JREJfREJfVkVSU0lPTixcbiAgICBASW5qZWN0KElEQl9OT19XUkFQKSBub1dyYXAgPSBERUZBVUxUX0lEQl9OT19XUkFQLFxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbiAgICBASW5qZWN0KExPQ0FMX1NUT1JBR0VfUFJFRklYKSBvbGRQcmVmaXggPSAnJyxcbiAgKSB7XG5cbiAgICAvKiBJbml0aWFsaXplIGBpbmRleGVkREJgIGRhdGFiYXNlIG5hbWUsIHdpdGggcHJlZml4IGlmIHByb3ZpZGVkIGJ5IHRoZSB1c2VyICovXG4gICAgdGhpcy5kYk5hbWUgPSBvbGRQcmVmaXggPyBgJHtvbGRQcmVmaXh9XyR7ZGJOYW1lfWAgOiBkYk5hbWU7XG5cbiAgICB0aGlzLnN0b3JlTmFtZSA9IHN0b3JlTmFtZTtcbiAgICB0aGlzLmRiVmVyc2lvbiA9IGRiVmVyc2lvbjtcbiAgICB0aGlzLm5vV3JhcCA9IG5vV3JhcDtcblxuICAgIC8qIENvbm5lY3QgdG8gYGluZGV4ZWREQmAsIHdpdGggcHJlZml4IGlmIHByb3ZpZGVkIGJ5IHRoZSB1c2VyICovXG4gICAgdGhpcy5jb25uZWN0KCk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBJbmZvcm1hdGlvbiBhYm91dCBgaW5kZXhlZERCYCBjb25uZWN0aW9uLiAqT25seSB1c2VmdWwgZm9yIGludGVyb3BlcmFiaWxpdHkuKlxuICAgKiBAcmV0dXJucyBgaW5kZXhlZERCYCBkYXRhYmFzZSBuYW1lLCBzdG9yZSBuYW1lIGFuZCBkYXRhYmFzZSB2ZXJzaW9uXG4gICAqL1xuICBnZXQgYmFja2luZ1N0b3JlKCk6IHsgZGF0YWJhc2U6IHN0cmluZywgc3RvcmU6IHN0cmluZywgdmVyc2lvbjogbnVtYmVyIH0ge1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGFiYXNlOiB0aGlzLmRiTmFtZSxcbiAgICAgIHN0b3JlOiB0aGlzLnN0b3JlTmFtZSxcbiAgICAgIHZlcnNpb246IHRoaXMuZGJWZXJzaW9uLFxuICAgIH07XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgaXRlbXMgaW4gb3VyIGBpbmRleGVkREJgIGRhdGFiYXNlIGFuZCBvYmplY3Qgc3RvcmVcbiAgICovXG4gIGdldCBzaXplKCk6IE9ic2VydmFibGU8bnVtYmVyPiB7XG5cbiAgICAvKiBPcGVuIGEgdHJhbnNhY3Rpb24gaW4gcmVhZC1vbmx5IG1vZGUgKi9cbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbigncmVhZG9ubHknKS5waXBlKFxuICAgICAgbWVyZ2VNYXAoKHN0b3JlKSA9PiB7XG5cbiAgICAgICAgLyogUmVxdWVzdCB0byBrbm93IHRoZSBudW1iZXIgb2YgaXRlbXMgKi9cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmNvdW50KCk7XG5cbiAgICAgICAgLyogTWFuYWdlIHN1Y2Nlc3MgYW5kIGVycm9yIGV2ZW50cywgYW5kIGdldCB0aGUgcmVzdWx0ICovXG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RFdmVudHNBbmRNYXBUbyhyZXF1ZXN0LCAoKSA9PiByZXF1ZXN0LnJlc3VsdCk7XG5cbiAgICAgIH0pLFxuICAgICAgLyogVGhlIG9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSBhZnRlciB0aGUgZmlyc3QgdmFsdWUgKi9cbiAgICAgIGZpcnN0KCksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gaXRlbSB2YWx1ZSBpbiBvdXIgYGluZGV4ZWREQmAgc3RvcmVcbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgKiBAcmV0dXJucyBUaGUgaXRlbSdzIHZhbHVlIGlmIHRoZSBrZXkgZXhpc3RzLCBgdW5kZWZpbmVkYCBvdGhlcndpc2UsIHdyYXBwZWQgaW4gYW4gUnhKUyBgT2JzZXJ2YWJsZWBcbiAgICovXG4gIGdldDxUID0gYW55PihrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8VMKgfCB1bmRlZmluZWQ+IHtcblxuICAgIC8qIE9wZW4gYSB0cmFuc2FjdGlvbiBpbiByZWFkLW9ubHkgbW9kZSAqL1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKCdyZWFkb25seScpLnBpcGUoXG4gICAgICBtZXJnZU1hcCgoc3RvcmUpID0+IHtcblxuICAgICAgICAvKiBSZXF1ZXN0IHRoZSB2YWx1ZSB3aXRoIHRoZSBrZXkgcHJvdmlkZWQgYnkgdGhlIHVzZXIgKi9cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmdldChrZXkpO1xuXG4gICAgICAgIC8qIE1hbmFnZSBzdWNjZXNzIGFuZCBlcnJvciBldmVudHMsIGFuZCBnZXQgdGhlIHJlc3VsdCAqL1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RXZlbnRzQW5kTWFwVG8ocmVxdWVzdCwgKCkgPT4ge1xuXG4gICAgICAgICAgaWYgKChyZXF1ZXN0LnJlc3VsdCAhPT0gdW5kZWZpbmVkKSAmJiAocmVxdWVzdC5yZXN1bHQgIT09IG51bGwpKSB7XG5cbiAgICAgICAgICAgIC8qIFByaW9yIHRvIHY4LCB0aGUgdmFsdWUgd2FzIHdyYXBwZWQgaW4gYW4gYHsgdmFsdWU6IC4uLn1gIG9iamVjdCAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vV3JhcCAmJiAodHlwZW9mIHJlcXVlc3QucmVzdWx0ID09PSAnb2JqZWN0JykgJiYgKHRoaXMud3JhcEluZGV4IGluIHJlcXVlc3QucmVzdWx0KSAmJlxuICAgICAgICAgICAgKHJlcXVlc3QucmVzdWx0W3RoaXMud3JhcEluZGV4XSAhPT0gdW5kZWZpbmVkKSAmJiAocmVxdWVzdC5yZXN1bHRbdGhpcy53cmFwSW5kZXhdICE9PSBudWxsKSkge1xuXG4gICAgICAgICAgICAgIHJldHVybiAocmVxdWVzdC5yZXN1bHRbdGhpcy53cmFwSW5kZXhdIGFzIFQpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgIC8qIENhc3QgdG8gdGhlIHdhbnRlZCB0eXBlICovXG4gICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0LnJlc3VsdCBhcyBUO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKiBSZXR1cm4gYHVuZGVmaW5lZGAgaWYgdGhlIHZhbHVlIGlzIGVtcHR5ICovXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgICB9KTtcblxuICAgICAgfSksXG4gICAgICAvKiBUaGUgb2JzZXJ2YWJsZSB3aWxsIGNvbXBsZXRlIGFmdGVyIHRoZSBmaXJzdCB2YWx1ZSAqL1xuICAgICAgZmlyc3QoKSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhbiBpdGVtIGluIG91ciBgaW5kZXhlZERCYCBzdG9yZVxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEBwYXJhbSBkYXRhIFRoZSBpdGVtJ3MgdmFsdWVcbiAgICogQHJldHVybnMgQW4gUnhKUyBgT2JzZXJ2YWJsZWAgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIHNldChrZXk6IHN0cmluZywgZGF0YTogYW55KTogT2JzZXJ2YWJsZTx1bmRlZmluZWQ+IHtcblxuICAgIC8qIFN0b3JpbmcgYHVuZGVmaW5lZGAgaW4gYGluZGV4ZWREYmAgY2FuIGNhdXNlIGlzc3VlcyBpbiBzb21lIGJyb3dzZXJzIHNvIHJlbW92aW5nIGl0ZW0gaW5zdGVhZCAqL1xuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbGV0ZShrZXkpO1xuICAgIH1cblxuICAgIC8qIE9wZW4gYSB0cmFuc2FjdGlvbiBpbiB3cml0ZSBtb2RlICovXG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24oJ3JlYWR3cml0ZScpLnBpcGUoXG4gICAgICBtZXJnZU1hcCgoc3RvcmUpID0+IHtcblxuICAgICAgICAvKiBDaGVjayBpZiB0aGUga2V5IGFscmVhZHkgZXhpc3RzIG9yIG5vdFxuICAgICAgICAgKiBgZ2V0S2V5KClgIGlzIGJldHRlciBidXQgb25seSBhdmFpbGFibGUgaW4gYGluZGV4ZWREQmAgdjIgKENocm9tZSA+PSA1OCwgbWlzc2luZyBpbiBJRS9FZGdlKS5cbiAgICAgICAgICogSW4gb2xkZXIgYnJvd3NlcnMsIHRoZSB2YWx1ZSBpcyBjaGVja2VkIGluc3RlYWQsIGJ1dCBpdCBjb3VsZCBsZWFkIHRvIGFuIGV4Y2VwdGlvblxuICAgICAgICAgKiBpZiBgdW5kZWZpbmVkYCB3YXMgc3RvcmVkIG91dHNpZGUgb2YgdGhpcyBsaWIgKGUuZy4gZGlyZWN0bHkgd2l0aCB0aGUgbmF0aXZlIGBpbmRleGVkREJgIEFQSSkuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZXF1ZXN0R2V0ID0gdGhpcy5nZXRLZXlSZXF1ZXN0KHN0b3JlLCBrZXkpO1xuXG4gICAgICAgIC8qIE1hbmFnZSBzdWNjZXNzIGFuZCBlcnJvciBldmVudHMsIGFuZCBnZXQgdGhlIHJlcXVlc3QgcmVzdWx0ICovXG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RFdmVudHNBbmRNYXBUbyhyZXF1ZXN0R2V0LCAoKSA9PiByZXF1ZXN0R2V0LnJlc3VsdCkucGlwZShcbiAgICAgICAgICBtZXJnZU1hcCgoZXhpc3RpbmdFbnRyeSkgPT4ge1xuXG4gICAgICAgICAgICAvKiBJdCBpcyB2ZXJ5IGltcG9ydGFudCB0aGUgc2Vjb25kIHJlcXVlc3QgaXMgZG9uZSBmcm9tIHRoZSBzYW1lIHRyYW5zYWN0aW9uL3N0b3JlIGFzIHRoZSBwcmV2aW91cyBvbmUsXG4gICAgICAgICAgICAgKiBvdGhlcndpc2UgaXQgY291bGQgbGVhZCB0byBjb25jdXJyZW5jeSBmYWlsdXJlc1xuICAgICAgICAgICAgICogQXZvaWQgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9pc3N1ZXMvNDcgKi9cblxuICAgICAgICAgICAgLyogUHJpb3IgdG8gdjgsIGRhdGEgd2FzIHdyYXBwZWQgaW4gYSBgeyB2YWx1ZTogLi4uIH1gIG9iamVjdCAqL1xuICAgICAgICAgICAgY29uc3QgZGF0YVRvU3RvcmUgPSB0aGlzLm5vV3JhcCA/IGRhdGEgOiB7IFt0aGlzLndyYXBJbmRleF06IGRhdGEgfTtcblxuICAgICAgICAgICAgLyogQWRkIGlmIHRoZSBpdGVtIGlzIG5vdCBleGlzdGluZyB5ZXQsIG9yIHVwZGF0ZSBvdGhlcndpc2UgKi9cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RTZXQgPSAoZXhpc3RpbmdFbnRyeSA9PT0gdW5kZWZpbmVkKSA/XG4gICAgICAgICAgICAgIHN0b3JlLmFkZChkYXRhVG9TdG9yZSwga2V5KSA6XG4gICAgICAgICAgICAgIHN0b3JlLnB1dChkYXRhVG9TdG9yZSwga2V5KTtcblxuICAgICAgICAgICAgLyogTWFuYWdlIHN1Y2Nlc3MgYW5kIGVycm9yIGV2ZW50cywgYW5kIG1hcCB0byBgdHJ1ZWAgKi9cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RFdmVudHNBbmRNYXBUbyhyZXF1ZXN0U2V0LCAoKSA9PiB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgfSksXG4gICAgICAgICk7XG4gICAgICB9KSxcbiAgICAgIC8qIFRoZSBvYnNlcnZhYmxlIHdpbGwgY29tcGxldGUgYWZ0ZXIgdGhlIGZpcnN0IHZhbHVlICovXG4gICAgICBmaXJzdCgpLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGl0ZW0gaW4gb3VyIGBpbmRleGVkREJgIHN0b3JlXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHJldHVybnMgQW4gUnhKUyBgT2JzZXJ2YWJsZWAgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIGRlbGV0ZShrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8dW5kZWZpbmVkPiB7XG5cbiAgICAvKiBPcGVuIGEgdHJhbnNhY3Rpb24gaW4gd3JpdGUgbW9kZSAqL1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnKS5waXBlKFxuICAgICAgbWVyZ2VNYXAoKHN0b3JlKSA9PiB7XG5cbiAgICAgICAgLyogRGVsZXRldGhlIGl0ZW0gaW4gc3RvcmUgKi9cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmRlbGV0ZShrZXkpO1xuXG4gICAgICAgIC8qIE1hbmFnZSBzdWNjZXNzIGFuZCBlcnJvciBldmVudHMsIGFuZCBtYXAgdG8gYHRydWVgICovXG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RFdmVudHNBbmRNYXBUbyhyZXF1ZXN0LCAoKSA9PiB1bmRlZmluZWQpO1xuXG4gICAgICB9KSxcbiAgICAgIC8qIFRoZSBvYnNlcnZhYmxlIHdpbGwgY29tcGxldGUgYWZ0ZXIgdGhlIGZpcnN0IHZhbHVlICovXG4gICAgICBmaXJzdCgpLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFsbCBpdGVtcyBmcm9tIG91ciBgaW5kZXhlZERCYCBvYmpldCBzdG9yZVxuICAgKiBAcmV0dXJucyBBbiBSeEpTIGBPYnNlcnZhYmxlYCB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgKi9cbiAgY2xlYXIoKTogT2JzZXJ2YWJsZTx1bmRlZmluZWQ+IHtcblxuICAgIC8qIE9wZW4gYSB0cmFuc2FjdGlvbiBpbiB3cml0ZSBtb2RlICovXG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24oJ3JlYWR3cml0ZScpLnBpcGUoXG4gICAgICBtZXJnZU1hcCgoc3RvcmUpID0+IHtcblxuICAgICAgICAvKiBEZWxldGUgYWxsIGl0ZW1zIGluIG9iamVjdCBzdG9yZSAqL1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuY2xlYXIoKTtcblxuICAgICAgICAvKiBNYW5hZ2Ugc3VjY2VzcyBhbmQgZXJyb3IgZXZlbnRzLCBhbmQgbWFwIHRvIGB0cnVlYCAqL1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RXZlbnRzQW5kTWFwVG8ocmVxdWVzdCwgKCkgPT4gdW5kZWZpbmVkKTtcblxuICAgICAgfSksXG4gICAgICAvKiBUaGUgb2JzZXJ2YWJsZSB3aWxsIGNvbXBsZXRlICovXG4gICAgICBmaXJzdCgpLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHRoZSBrZXlzIGluIG91ciBgaW5kZXhlZERCYCBzdG9yZVxuICAgKiBAcmV0dXJucyBBbiBSeEpTIGBPYnNlcnZhYmxlYCBpdGVyYXRpbmcgb24gZWFjaCBrZXlcbiAgICovXG4gIGtleXMoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblxuICAgIC8qIE9wZW4gYSB0cmFuc2FjdGlvbiBpbiByZWFkLW9ubHkgbW9kZSAqL1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKCdyZWFkb25seScpLnBpcGUoXG4gICAgICAvKiBgZmlyc3QoKWAgaXMgdXNlZCBhcyB0aGUgZmluYWwgb3BlcmF0b3IgaW4gb3RoZXIgbWV0aG9kcyB0byBjb21wbGV0ZSB0aGUgYE9ic2VydmFibGVgXG4gICAgICAgKiAoYXMgaXQgYWxsIHN0YXJ0cyBmcm9tIGEgYFJlcGxheVN1YmplY3RgIHdoaWNoIG5ldmVyIGVuZHMpLFxuICAgICAgICogYnV0IGFzIHRoaXMgbWV0aG9kIGlzIGl0ZXJhdGluZyBvdmVyIG11bHRpcGxlIHZhbHVlcywgYGZpcnN0KClgICoqbXVzdCoqIGJlIHVzZWQgaGVyZSAqL1xuICAgICAgZmlyc3QoKSxcbiAgICAgIG1lcmdlTWFwKChzdG9yZSkgPT4ge1xuXG4gICAgICAgIC8qIE9wZW4gYSBjdXJzb3Igb24gdGhlIHN0b3JlXG4gICAgICAgICAqIGAub3BlbktleUN1cnNvcigpYCBpcyBiZXR0ZXIgZm9yIHBlcmZvcm1hbmNlLCBidXQgb25seSBhdmFpbGFibGUgaW4gaW5kZXhlZERCIHYyIChtaXNzaW5nIGluIElFL0VkZ2UpXG4gICAgICAgICAqIEF2b2lkIGlzc3VlcyBsaWtlIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvaXNzdWVzLzY5ICovXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSAoJ29wZW5LZXlDdXJzb3InIGluIHN0b3JlKSA/IHN0b3JlLm9wZW5LZXlDdXJzb3IoKSA6IChzdG9yZSBhcyBJREJPYmplY3RTdG9yZSkub3BlbkN1cnNvcigpO1xuXG4gICAgICAgIC8qIExpc3RlbiB0byBzdWNjZXNzIGV2ZW50ICovXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MkID0gdGhpcy5zdWNjZXNzRXZlbnQocmVxdWVzdCkucGlwZShcbiAgICAgICAgICAvKiBTdG9wIHRoZSBgT2JzZXJ2YWJsZWAgd2hlbiB0aGUgY3Vyc29yIGlzIGBudWxsYCAqL1xuICAgICAgICAgIHRha2VXaGlsZSgoKSA9PiAocmVxdWVzdC5yZXN1bHQgIT09IG51bGwpKSxcbiAgICAgICAgICAvKiBUaGlzIGxpYiBvbmx5IGFsbG93cyBzdHJpbmcga2V5cywgYnV0IHVzZXIgY291bGQgaGF2ZSBhZGRlZCBvdGhlciB0eXBlcyBvZiBrZXlzIGZyb20gb3V0c2lkZVxuICAgICAgICAgICAqIEl0J3MgT0sgdG8gY2FzdCBhcyB0aGUgY3Vyc29yIGFzIGJlZW4gdGVzdGVkIGluIHRoZSBwcmV2aW91cyBvcGVyYXRvciAqL1xuICAgICAgICAgIG1hcCgoKSA9PiAocmVxdWVzdC5yZXN1bHQgYXMgSURCQ3Vyc29yKS5rZXkudG9TdHJpbmcoKSksXG4gICAgICAgICAgLyogSXRlcmF0ZSBvbiB0aGUgY3Vyc29yICovXG4gICAgICAgICAgdGFwKCgpID0+IHsgKHJlcXVlc3QucmVzdWx0IGFzIElEQkN1cnNvcikuY29udGludWUoKTsgfSksXG4gICAgICAgICk7XG5cbiAgICAgICAgLyogTGlzdGVuIHRvIGVycm9yIGV2ZW50IGFuZCBpZiBzbywgdGhyb3cgYW4gZXJyb3IgKi9cbiAgICAgICAgY29uc3QgZXJyb3IkID0gdGhpcy5lcnJvckV2ZW50KHJlcXVlc3QpO1xuXG4gICAgICAgIC8qIENob29zZSB0aGUgZmlyc3QgZXZlbnQgdG8gb2NjdXIgKi9cbiAgICAgICAgcmV0dXJuIHJhY2UoW3N1Y2Nlc3MkLCBlcnJvciRdKTtcblxuICAgICAgfSksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEga2V5IGV4aXN0cyBpbiBvdXIgYGluZGV4ZWREQmAgc3RvcmVcbiAgICogQHJldHVybnMgQW4gUnhKUyBgT2JzZXJ2YWJsZWAgdGVsbGluZyBpZiB0aGUga2V5IGV4aXN0cyBvciBub3RcbiAgICovXG4gIGhhcyhrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuXG4gICAgLyogT3BlbiBhIHRyYW5zYWN0aW9uIGluIHJlYWQtb25seSBtb2RlICovXG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24oJ3JlYWRvbmx5JykucGlwZShcbiAgICAgIG1lcmdlTWFwKChzdG9yZSkgPT4ge1xuXG4gICAgICAgIC8qIENoZWNrIGlmIHRoZSBrZXkgZXhpc3RzIGluIHRoZSBzdG9yZSAqL1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5nZXRLZXlSZXF1ZXN0KHN0b3JlLCBrZXkpO1xuXG4gICAgICAgIC8qIE1hbmFnZSBzdWNjZXNzIGFuZCBlcnJvciBldmVudHMsIGFuZCBtYXAgdG8gYSBib29sZWFuIGJhc2VkIG9uIHRoZSBleGlzdGVuY2Ugb2YgdGhlIGtleSAqL1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RXZlbnRzQW5kTWFwVG8ocmVxdWVzdCwgKCkgPT4gKHJlcXVlc3QucmVzdWx0ICE9PSB1bmRlZmluZWQpID8gdHJ1ZSA6IGZhbHNlKTtcblxuICAgICAgfSksXG4gICAgICAvKiBUaGUgb2JzZXJ2YWJsZSB3aWxsIGNvbXBsZXRlICovXG4gICAgICBmaXJzdCgpXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRvIGBpbmRleGVkREJgIGFuZCBjcmVhdGVzIHRoZSBvYmplY3Qgc3RvcmUgb24gZmlyc3QgdGltZVxuICAgKi9cbiAgcHJvdGVjdGVkIGNvbm5lY3QoKTogdm9pZCB7XG5cbiAgICBsZXQgcmVxdWVzdDogSURCT3BlbkRCUmVxdWVzdDtcblxuICAgIC8qIENvbm5lY3QgdG8gYGluZGV4ZWREQmBcbiAgICAgKiBXaWxsIGZhaWwgaW4gU2FmYXJpIGNyb3NzLW9yaWdpbiBpZnJhbWVzXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9pc3N1ZXMvNDJ9ICovXG4gICAgdHJ5IHtcblxuICAgICAgLyogRG8gTk9UIGV4cGxpY2l0IGB3aW5kb3dgIGhlcmUsIGFzIGBpbmRleGVkREJgIGNvdWxkIGJlIHVzZWQgZnJvbSBhIHdlYiB3b3JrZXIgdG9vICovXG4gICAgICByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4odGhpcy5kYk5hbWUsIHRoaXMuZGJWZXJzaW9uKTtcblxuICAgIH3CoGNhdGNoIHtcblxuICAgICAgdGhpcy5kYXRhYmFzZS5lcnJvcihuZXcgSURCQnJva2VuRXJyb3IoKSk7XG5cbiAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIC8qIENyZWF0ZSBzdG9yZSBvbiBmaXJzdCBjb25uZWN0aW9uICovXG4gICAgdGhpcy5jcmVhdGVTdG9yZShyZXF1ZXN0KTtcblxuICAgIC8qIExpc3RlbiB0byBzdWNjZXNzIGFuZCBlcnJvciBldmVudHMgYW5kIGNob29zZSB0aGUgZmlyc3QgdG8gb2NjdXIgKi9cbiAgICByYWNlKFt0aGlzLnN1Y2Nlc3NFdmVudChyZXF1ZXN0KSwgdGhpcy5lcnJvckV2ZW50KHJlcXVlc3QpXSlcbiAgICAgIC8qIFRoZSBvYnNlcnZhYmxlIHdpbGwgY29tcGxldGUgKi9cbiAgICAgIC5waXBlKGZpcnN0KCkpXG4gICAgICAuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgIC8qIFJlZ2lzdGVyIHRoZSBkYXRhYmFzZSBjb25uZWN0aW9uIGluIHRoZSBgUmVwbGF5U3ViamVjdGAgZm9yIGZ1cnRoZXIgYWNjZXNzICovXG4gICAgICAgICAgdGhpcy5kYXRhYmFzZS5uZXh0KHJlcXVlc3QucmVzdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6ICgpID0+IHtcbiAgICAgICAgICAvKiBGaXJlZm94IHByaXZhdGUgbW9kZSBpc3N1ZTogZmFsbGJhY2sgc3RvcmFnZSBpZiBJbmRleGVkRGIgY29ubmVjdGlvbiBpcyBmYWlsaW5nXG4gICAgICAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03ODE5ODJ9XG4gICAgICAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2lzc3Vlcy8yNn0gKi9cbiAgICAgICAgICB0aGlzLmRhdGFiYXNlLmVycm9yKG5ldyBJREJCcm9rZW5FcnJvcigpKTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHN0b3JlIG9uIGZpcnN0IHVzZSBvZiBgaW5kZXhlZERCYFxuICAgKiBAcGFyYW0gcmVxdWVzdCBgaW5kZXhlZERCYCBkYXRhYmFzZSBvcGVuaW5nIHJlcXVlc3RcbiAgICovXG4gIHByb3RlY3RlZCBjcmVhdGVTdG9yZShyZXF1ZXN0OiBJREJPcGVuREJSZXF1ZXN0KTogdm9pZCB7XG5cbiAgICAvKiBMaXN0ZW4gdG8gdGhlIGV2ZW50IGZpcmVkIG9uIGZpcnN0IGNvbm5lY3Rpb24gKi9cbiAgICBmcm9tRXZlbnQocmVxdWVzdCwgJ3VwZ3JhZGVuZWVkZWQnKVxuICAgICAgLyogVGhlIG9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSAqL1xuICAgICAgLnBpcGUoZmlyc3QoKSlcbiAgICAgIC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiAoKSA9PiB7XG5cbiAgICAgICAgICAvKiBDaGVjayBpZiB0aGUgc3RvcmUgYWxyZWFkeSBleGlzdHMsIHRvIGF2b2lkIGVycm9yICovXG4gICAgICAgICAgaWYgKCFyZXF1ZXN0LnJlc3VsdC5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKHRoaXMuc3RvcmVOYW1lKSkge1xuXG4gICAgICAgICAgICAvKiBDcmVhdGUgdGhlIG9iamVjdCBzdG9yZSAqL1xuICAgICAgICAgICAgcmVxdWVzdC5yZXN1bHQuY3JlYXRlT2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gIH1cblxuICAvKipcbiAgICogT3BlbiBhbiBgaW5kZXhlZERCYCB0cmFuc2FjdGlvbiBhbmQgZ2V0IG91ciBzdG9yZVxuICAgKiBAcGFyYW0gbW9kZSBgcmVhZG9ubHlgIG9yIGByZWFkd3JpdGVgXG4gICAqIEByZXR1cm5zIEFuIGBpbmRleGVkREJgIHN0b3JlLCB3cmFwcGVkIGluIGFuIFJ4SlMgYE9ic2VydmFibGVgXG4gICAqL1xuICBwcm90ZWN0ZWQgdHJhbnNhY3Rpb24obW9kZTogSURCVHJhbnNhY3Rpb25Nb2RlKTogT2JzZXJ2YWJsZTxJREJPYmplY3RTdG9yZT4ge1xuXG4gICAgLyogRnJvbSB0aGUgYGluZGV4ZWREQmAgY29ubmVjdGlvbiwgb3BlbiBhIHRyYW5zYWN0aW9uIGFuZCBnZXQgdGhlIHN0b3JlICovXG4gICAgcmV0dXJuIHRoaXMuZGF0YWJhc2VcbiAgICAgIC5waXBlKG1lcmdlTWFwKChkYXRhYmFzZSkgPT4ge1xuXG4gICAgICAgIGxldCBzdG9yZTogSURCT2JqZWN0U3RvcmU7XG5cbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgIHN0b3JlID0gZGF0YWJhc2UudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgbW9kZSkub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG5cbiAgICAgICAgICAgIC8qIFRoZSBzdG9yZSBjb3VsZCBoYXZlIGJlZW4gZGVsZXRlZCBmcm9tIG91dHNpZGUgKi9cbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycm9yIGFzIERPTUV4Y2VwdGlvbik7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvZihzdG9yZSk7XG5cbiAgICAgIH0pKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBhbiBgaW5kZXhlZERCYCBzdWNjZXNzIGVycm9yIGV2ZW50XG4gICAqIEBwYXJhbSByZXF1ZXN0IFJlcXVlc3QgdG8gbGlzdGVuXG4gICAqIEByZXR1cm5zIEFuIFJ4SlMgYE9ic2VydmFibGVgIGxpc3RlbmluZyB0byB0aGUgc3VjY2VzcyBldmVudFxuICAgKi9cbiAgcHJvdGVjdGVkIHN1Y2Nlc3NFdmVudChyZXF1ZXN0OiBJREJSZXF1ZXN0KTogT2JzZXJ2YWJsZTxFdmVudD4ge1xuXG4gICAgcmV0dXJuIGZyb21FdmVudChyZXF1ZXN0LCAnc3VjY2VzcycpO1xuXG4gIH1cblxuICAvKipcbiAgICogTGlzdGVuIHRvIGFuIGBpbmRleGVkREJgIHJlcXVlc3QgZXJyb3IgZXZlbnRcbiAgICogQHBhcmFtIHJlcXVlc3QgUmVxdWVzdCB0byBsaXN0ZW5cbiAgICogQHJldHVybnMgQW4gUnhKUyBgT2JzZXJ2YWJsZWAgbGlzdGVuaW5nIHRvIHRoZSBlcnJvciBldmVudCBhbmQgaWYgc28sIHRocm93aW5nIGFuIGVycm9yXG4gICAqL1xuICBwcm90ZWN0ZWQgZXJyb3JFdmVudChyZXF1ZXN0OiBJREJSZXF1ZXN0KTogT2JzZXJ2YWJsZTxuZXZlcj4ge1xuXG4gICAgcmV0dXJuIGZyb21FdmVudChyZXF1ZXN0LCAnZXJyb3InKS5waXBlKG1lcmdlTWFwKCgpID0+IHRocm93RXJyb3IocmVxdWVzdC5lcnJvciBhcyBET01FeGNlcHRpb24pKSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gYW4gYGluZGV4ZWREQmAgcmVxdWVzdCBzdWNjZXNzIGFuZCBlcnJvciBldmVudCwgYW5kIG1hcCB0byB0aGUgd2FudGVkIHZhbHVlXG4gICAqIEBwYXJhbSByZXF1ZXN0IFJlcXVlc3QgdG8gbGlzdGVuXG4gICAqIEBwYXJhbSBtYXBDYWxsYmFjayBDYWxsYmFjayByZXR1cm5pbmcgdGhlIHdhbnRlZCB2YWx1ZVxuICAgKiBAcmV0dXJucyBBbiBSeEpTIGBPYnNlcnZhYmxlYCBsaXN0ZW5pbmcgdG8gcmVxdWVzdCBldmVudHMgYW5kIG1hcHBpbmcgdG8gdGhlIHdhbnRlZCB2YWx1ZVxuICAgKi9cbiAgcHJvdGVjdGVkIHJlcXVlc3RFdmVudHNBbmRNYXBUbzxUPihyZXF1ZXN0OiBJREJSZXF1ZXN0LCBtYXBDYWxsYmFjazogKCkgPT4gVCk6IE9ic2VydmFibGU8VD4ge1xuXG4gICAgLyogTGlzdGVuIHRvIHRoZSBzdWNjZXNzIGV2ZW50IGFuZCBtYXAgdG8gdGhlIHdhbnRlZCB2YWx1ZVxuICAgICAqIGBtYXBUbygpYCBtdXN0IG5vdCBiZSB1c2VkIGhlcmUgYXMgaXQgd291bGQgZXZhbCBgcmVxdWVzdC5yZXN1bHRgIHRvbyBzb29uICovXG4gICAgY29uc3Qgc3VjY2VzcyQgPSB0aGlzLnN1Y2Nlc3NFdmVudChyZXF1ZXN0KS5waXBlKG1hcChtYXBDYWxsYmFjaykpO1xuXG4gICAgLyogTGlzdGVuIHRvIHRoZSBlcnJvciBldmVudCAqL1xuICAgIGNvbnN0IGVycm9yJCA9IHRoaXMuZXJyb3JFdmVudChyZXF1ZXN0KTtcblxuICAgIC8qIENob29zZSB0aGUgZmlyc3QgZXZlbnQgdG8gb2NjdXIgKi9cbiAgICByZXR1cm4gcmFjZShbc3VjY2VzcyQsIGVycm9yJF0pO1xuXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGtleSBleGlzdHMgaW4gdGhlIHN0b3JlXG4gICAqIEBwYXJhbSBzdG9yZSBPYmpldCBzdG9yZSBvbiB3aGljaCB0byBwZXJmb3JtIHRoZSByZXF1ZXN0XG4gICAqIEBwYXJhbSBrZXkgS2V5IHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIEFuIGBpbmRleGVkREJgIHJlcXVlc3RcbiAgICovXG4gIHByb3RlY3RlZCBnZXRLZXlSZXF1ZXN0KHN0b3JlOiBJREJPYmplY3RTdG9yZSwga2V5OiBzdHJpbmcpOiBJREJSZXF1ZXN0IHtcblxuICAgIC8qIGBnZXRLZXkoKWAgaXMgYmV0dGVyIGJ1dCBvbmx5IGF2YWlsYWJsZSBpbiBgaW5kZXhlZERCYCB2MiAoQ2hyb21lID49IDU4LCBtaXNzaW5nIGluIElFL0VkZ2UpLlxuICAgICAqIEluIG9sZGVyIGJyb3dzZXJzLCB0aGUgdmFsdWUgaXMgY2hlY2tlZCBpbnN0ZWFkLCBidXQgaXQgY291bGQgbGVhZCB0byBhbiBleGNlcHRpb25cbiAgICAgKiBpZiBgdW5kZWZpbmVkYCB3YXMgc3RvcmVkIG91dHNpZGUgb2YgdGhpcyBsaWIgKGUuZy4gZGlyZWN0bHkgd2l0aCB0aGUgbmF0aXZlIGBpbmRleGVkREJgIEFQSSkuXG4gICAgICogRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9pc3N1ZXMvNjlcbiAgICAgKi9cbiAgICByZXR1cm4gKCdnZXRLZXknIGluIHN0b3JlKSA/IHN0b3JlLmdldEtleShrZXkpIDogKHN0b3JlIGFzIElEQk9iamVjdFN0b3JlKS5nZXQoa2V5KTtcblxuICB9XG5cbn1cbiJdfQ==