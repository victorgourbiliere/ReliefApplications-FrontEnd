import * as tslib_1 from "tslib";
import { Injectable, Inject } from '@angular/core';
import { throwError, of } from 'rxjs';
import { mergeMap, catchError } from 'rxjs/operators';
import { ValidationError } from './exceptions';
import { JSONValidator } from '../validation';
import { LocalDatabase, IDB_BROKEN_ERROR, LocalStorageDatabase, IndexedDBDatabase, MemoryDatabase } from '../databases';
import { LS_PREFIX, LOCAL_STORAGE_PREFIX } from '../tokens';
import * as i0 from "@angular/core";
import * as i1 from "../databases/local-database";
import * as i2 from "../validation/json-validator";
import * as i3 from "../tokens";
var StorageMap = /** @class */ (function () {
    /**
     * Constructor params are provided by Angular (but can also be passed manually in tests)
     * @param database Storage to use
     * @param jsonValidator Validator service
     * @param LSPrefix Prefix for `localStorage` keys to avoid collision for multiple apps on the same subdomain or for interoperability
     * @param oldPrefix Prefix option prior to v8 to avoid collision for multiple apps on the same subdomain or for interoperability
     */
    function StorageMap(database, jsonValidator, LSPrefix, 
    // tslint:disable-next-line: deprecation
    oldPrefix) {
        if (jsonValidator === void 0) { jsonValidator = new JSONValidator(); }
        if (LSPrefix === void 0) { LSPrefix = ''; }
        if (oldPrefix === void 0) { oldPrefix = ''; }
        this.database = database;
        this.jsonValidator = jsonValidator;
        this.LSPrefix = LSPrefix;
        this.oldPrefix = oldPrefix;
    }
    Object.defineProperty(StorageMap.prototype, "size", {
        /**
         * **Number of items** in storage, wrapped in an `Observable`.
         *
         * @example
         * this.storageMap.size.subscribe((size) => {
         *   console.log(size);
         * });
         */
        get: function () {
            return this.database.size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StorageMap.prototype, "backingEngine", {
        /**
         * Tells you which storage engine is used. *Only useful for interoperability.*
         * Note that due to some browsers issues in some special contexts
         * (Firefox private mode and Safari cross-origin iframes),
         * **this information may be wrong at initialization,**
         * as the storage could fallback from `indexedDB` to `localStorage`
         * only after a first read or write operation.
         * @returns Storage engine used
         *
         * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/master/docs/INTEROPERABILITY.md}
         *
         * @example
         * if (this.storageMap.backingEngine === 'indexedDB') {}
         */
        get: function () {
            if (this.database instanceof IndexedDBDatabase) {
                return 'indexedDB';
            }
            else if (this.database instanceof LocalStorageDatabase) {
                return 'localStorage';
            }
            else if (this.database instanceof MemoryDatabase) {
                return 'memory';
            }
            else {
                return 'unknown';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StorageMap.prototype, "backingStore", {
        /**
         * Info about `indexedDB` database. *Only useful for interoperability.*
         * @returns `indexedDB` database name, store name and database version.
         * **Values will be empty if the storage is not `indexedDB`,**
         * **so it should be used after an engine check**.
         *
         * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/master/docs/INTEROPERABILITY.md}
         *
         * @example
         * if (this.storageMap.backingEngine === 'indexedDB') {
         *   const { database, store, version } = this.storageMap.backingStore;
         * }
         */
        get: function () {
            return (this.database instanceof IndexedDBDatabase) ?
                this.database.backingStore :
                { database: '', store: '', version: 0 };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StorageMap.prototype, "fallbackBackingStore", {
        /**
         * Info about `localStorage` fallback storage. *Only useful for interoperability.*
         * @returns `localStorage` prefix.
         * **Values will be empty if the storage is not `localStorage`,**
         * **so it should be used after an engine check**.
         *
         * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/master/docs/INTEROPERABILITY.md}
         *
         * @example
         * if (this.storageMap.backingEngine === 'localStorage') {
         *   const { prefix } = this.storageMap.fallbackBackingStore;
         * }
         */
        get: function () {
            return (this.database instanceof LocalStorageDatabase) ?
                { prefix: this.database.prefix } :
                { prefix: '' };
        },
        enumerable: true,
        configurable: true
    });
    StorageMap.prototype.get = function (key, schema) {
        var _this = this;
        /* Get the data in storage */
        return this.database.get(key).pipe(
        /* Check if `indexedDb` is broken */
        this.catchIDBBroken(function () { return _this.database.get(key); }), mergeMap(function (data) {
            /* No need to validate if the data is empty */
            if ((data === undefined) || (data === null)) {
                return of(undefined);
            }
            else if (schema) {
                /* Validate data against a JSON schema if provided */
                if (!_this.jsonValidator.validate(data, schema)) {
                    return throwError(new ValidationError());
                }
                /* Data have been checked, so it's OK to cast */
                return of(data);
            }
            /* Cast to unknown as the data wasn't checked */
            return of(data);
        }));
    };
    /**
     * Set an item in storage.
     * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.
     * @param key The item's key
     * @param data The item's value
     * @param schema Optional JSON schema to validate the data
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.storageMap.set('key', 'value').subscribe(() => {});
     */
    StorageMap.prototype.set = function (key, data, schema) {
        var _this = this;
        /* Storing `undefined` or `null` is useless and can cause issues in `indexedDb` in some browsers,
         * so removing item instead for all storages to have a consistent API */
        if ((data === undefined) || (data === null)) {
            return this.delete(key);
        }
        /* Validate data against a JSON schema if provided */
        if (schema && !this.jsonValidator.validate(data, schema)) {
            return throwError(new ValidationError());
        }
        return this.database.set(key, data)
            /* Catch if `indexedDb` is broken */
            .pipe(this.catchIDBBroken(function () { return _this.database.set(key, data); }));
    };
    /**
     * Delete an item in storage
     * @param key The item's key
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.storageMap.delete('key').subscribe(() => {});
     */
    StorageMap.prototype.delete = function (key) {
        var _this = this;
        return this.database.delete(key)
            /* Catch if `indexedDb` is broken */
            .pipe(this.catchIDBBroken(function () { return _this.database.delete(key); }));
    };
    /**
     * Delete all items in storage
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.storageMap.clear().subscribe(() => {});
     */
    StorageMap.prototype.clear = function () {
        var _this = this;
        return this.database.clear()
            /* Catch if `indexedDb` is broken */
            .pipe(this.catchIDBBroken(function () { return _this.database.clear(); }));
    };
    /**
     * Get all keys stored in storage. Note **this is an *iterating* `Observable`**:
     * * if there is no key, the `next` callback will not be invoked,
     * * if you need to wait the whole operation to end, be sure to act in the `complete` callback,
     * as this `Observable` can emit several values and so will invoke the `next` callback several times.
     * @returns A list of the keys wrapped in a RxJS `Observable`
     *
     * @example
     * this.storageMap.keys().subscribe({
     *   next: (key) => { console.log(key); },
     *   complete: () => { console.log('Done'); },
     * });
     */
    StorageMap.prototype.keys = function () {
        var _this = this;
        return this.database.keys()
            /* Catch if `indexedDb` is broken */
            .pipe(this.catchIDBBroken(function () { return _this.database.keys(); }));
    };
    /**
     * Tells if a key exists in storage
     * @returns A RxJS `Observable` telling if the key exists
     *
     * @example
     * this.storageMap.has('key').subscribe((hasKey) => {
     *   if (hasKey) {}
     * });
     */
    StorageMap.prototype.has = function (key) {
        var _this = this;
        return this.database.has(key)
            /* Catch if `indexedDb` is broken */
            .pipe(this.catchIDBBroken(function () { return _this.database.has(key); }));
    };
    /**
     * RxJS operator to catch if `indexedDB` is broken
     * @param operationCallback Callback with the operation to redo
     */
    StorageMap.prototype.catchIDBBroken = function (operationCallback) {
        var _this = this;
        return catchError(function (error) {
            /* Check if `indexedDB` is broken based on error message (the specific error class seems to be lost in the process) */
            if ((error !== undefined) && (error !== null) && (error.message === IDB_BROKEN_ERROR)) {
                /* When storage is fully disabled in browser (via the "Block all cookies" option),
                 * just trying to check `localStorage` variable causes a security exception.
                 * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118
                 */
                try {
                    if ('getItem' in localStorage) {
                        /* Fallback to `localStorage` if available */
                        _this.database = new LocalStorageDatabase(_this.LSPrefix, _this.oldPrefix);
                    }
                    else {
                        /* Fallback to memory storage otherwise */
                        _this.database = new MemoryDatabase();
                    }
                }
                catch (_a) {
                    /* Fallback to memory storage otherwise */
                    _this.database = new MemoryDatabase();
                }
                /* Redo the operation */
                return operationCallback();
            }
            else {
                /* Otherwise, rethrow the error */
                return throwError(error);
            }
        });
    };
    StorageMap.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function StorageMap_Factory() { return new StorageMap(i0.ɵɵinject(i1.LocalDatabase), i0.ɵɵinject(i2.JSONValidator), i0.ɵɵinject(i3.LS_PREFIX), i0.ɵɵinject(i3.LOCAL_STORAGE_PREFIX)); }, token: StorageMap, providedIn: "root" });
    StorageMap = tslib_1.__decorate([
        Injectable({
            providedIn: 'root'
        }),
        tslib_1.__param(2, Inject(LS_PREFIX)),
        tslib_1.__param(3, Inject(LOCAL_STORAGE_PREFIX)),
        tslib_1.__metadata("design:paramtypes", [LocalDatabase,
            JSONValidator, Object, Object])
    ], StorageMap);
    return StorageMap;
}());
export { StorageMap };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmFnZS1tYXAuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3gtcHdhL2xvY2FsLXN0b3JhZ2UvIiwic291cmNlcyI6WyJsaWIvc3RvcmFnZXMvc3RvcmFnZS1tYXAuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkQsT0FBTyxFQUFjLFVBQVUsRUFBRSxFQUFFLEVBQW9CLE1BQU0sTUFBTSxDQUFDO0FBQ3BFLE9BQU8sRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFdEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUMvQyxPQUFPLEVBRWtELGFBQWEsRUFDckUsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGFBQWEsRUFBRSxnQkFBZ0IsRUFBRSxvQkFBb0IsRUFBRSxpQkFBaUIsRUFBRSxjQUFjLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDeEgsT0FBTyxFQUFFLFNBQVMsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLFdBQVcsQ0FBQzs7Ozs7QUFLNUQ7SUFFRTs7Ozs7O09BTUc7SUFDSCxvQkFDWSxRQUF1QixFQUN2QixhQUFrRCxFQUMvQixRQUFhO0lBQzFDLHdDQUF3QztJQUNBLFNBQWM7UUFINUMsOEJBQUEsRUFBQSxvQkFBbUMsYUFBYSxFQUFFO1FBQy9CLHlCQUFBLEVBQUEsYUFBYTtRQUVGLDBCQUFBLEVBQUEsY0FBYztRQUo1QyxhQUFRLEdBQVIsUUFBUSxDQUFlO1FBQ3ZCLGtCQUFhLEdBQWIsYUFBYSxDQUFxQztRQUMvQixhQUFRLEdBQVIsUUFBUSxDQUFLO1FBRUYsY0FBUyxHQUFULFNBQVMsQ0FBSztJQUNyRCxDQUFDO0lBVUosc0JBQUksNEJBQUk7UUFSUjs7Ozs7OztXQU9HO2FBQ0g7WUFFRSxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFD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Q0FBQztJQUVMLENBQUM7O0lBM1VVLFVBQVU7UUFIdEIsVUFBVSxDQUFDO1lBQ1YsVUFBVSxFQUFFLE1BQU07U0FDbkIsQ0FBQztRQWFHLG1CQUFBLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQTtRQUVqQixtQkFBQSxNQUFNLENBQUMsb0JBQW9CLENBQUMsQ0FBQTtpREFKVCxhQUFhO1lBQ1IsYUFBYTtPQVg3QixVQUFVLENBNlV0QjtxQkE1VkQ7Q0E0VkMsQUE3VUQsSUE2VUM7U0E3VVksVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgdGhyb3dFcnJvciwgb2YsIE9wZXJhdG9yRnVuY3Rpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1lcmdlTWFwLCBjYXRjaEVycm9yIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3IgfSBmcm9tICcuL2V4Y2VwdGlvbnMnO1xuaW1wb3J0IHtcbiAgSlNPTlNjaGVtYSwgSlNPTlNjaGVtYUJvb2xlYW4sIEpTT05TY2hlbWFJbnRlZ2VyLFxuICBKU09OU2NoZW1hTnVtYmVyLCBKU09OU2NoZW1hU3RyaW5nLCBKU09OU2NoZW1hQXJyYXlPZiwgSlNPTlZhbGlkYXRvclxufSBmcm9tICcuLi92YWxpZGF0aW9uJztcbmltcG9ydCB7IExvY2FsRGF0YWJhc2UsIElEQl9CUk9LRU5fRVJST1IsIExvY2FsU3RvcmFnZURhdGFiYXNlLCBJbmRleGVkREJEYXRhYmFzZSwgTWVtb3J5RGF0YWJhc2UgfSBmcm9tICcuLi9kYXRhYmFzZXMnO1xuaW1wb3J0IHsgTFNfUFJFRklYLCBMT0NBTF9TVE9SQUdFX1BSRUZJWCB9IGZyb20gJy4uL3Rva2Vucyc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFN0b3JhZ2VNYXAge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBwYXJhbXMgYXJlIHByb3ZpZGVkIGJ5IEFuZ3VsYXIgKGJ1dCBjYW4gYWxzbyBiZSBwYXNzZWQgbWFudWFsbHkgaW4gdGVzdHMpXG4gICAqIEBwYXJhbSBkYXRhYmFzZSBTdG9yYWdlIHRvIHVzZVxuICAgKiBAcGFyYW0ganNvblZhbGlkYXRvciBWYWxpZGF0b3Igc2VydmljZVxuICAgKiBAcGFyYW0gTFNQcmVmaXggUHJlZml4IGZvciBgbG9jYWxTdG9yYWdlYCBrZXlzIHRvIGF2b2lkIGNvbGxpc2lvbiBmb3IgbXVsdGlwbGUgYXBwcyBvbiB0aGUgc2FtZSBzdWJkb21haW4gb3IgZm9yIGludGVyb3BlcmFiaWxpdHlcbiAgICogQHBhcmFtIG9sZFByZWZpeCBQcmVmaXggb3B0aW9uIHByaW9yIHRvIHY4IHRvIGF2b2lkIGNvbGxpc2lvbiBmb3IgbXVsdGlwbGUgYXBwcyBvbiB0aGUgc2FtZSBzdWJkb21haW4gb3IgZm9yIGludGVyb3BlcmFiaWxpdHlcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBkYXRhYmFzZTogTG9jYWxEYXRhYmFzZSxcbiAgICBwcm90ZWN0ZWQganNvblZhbGlkYXRvcjogSlNPTlZhbGlkYXRvciA9IG5ldyBKU09OVmFsaWRhdG9yKCksXG4gICAgQEluamVjdChMU19QUkVGSVgpIHByb3RlY3RlZCBMU1ByZWZpeCA9ICcnLFxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb25cbiAgICBASW5qZWN0KExPQ0FMX1NUT1JBR0VfUFJFRklYKSBwcm90ZWN0ZWQgb2xkUHJlZml4ID0gJycsXG4gICkge31cblxuICAvKipcbiAgICogKipOdW1iZXIgb2YgaXRlbXMqKiBpbiBzdG9yYWdlLCB3cmFwcGVkIGluIGFuIGBPYnNlcnZhYmxlYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5zdG9yYWdlTWFwLnNpemUuc3Vic2NyaWJlKChzaXplKSA9PiB7XG4gICAqICAgY29uc29sZS5sb2coc2l6ZSk7XG4gICAqIH0pO1xuICAgKi9cbiAgZ2V0IHNpemUoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcblxuICAgIHJldHVybiB0aGlzLmRhdGFiYXNlLnNpemU7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBUZWxscyB5b3Ugd2hpY2ggc3RvcmFnZSBlbmdpbmUgaXMgdXNlZC4gKk9ubHkgdXNlZnVsIGZvciBpbnRlcm9wZXJhYmlsaXR5LipcbiAgICogTm90ZSB0aGF0IGR1ZSB0byBzb21lIGJyb3dzZXJzIGlzc3VlcyBpbiBzb21lIHNwZWNpYWwgY29udGV4dHNcbiAgICogKEZpcmVmb3ggcHJpdmF0ZSBtb2RlIGFuZCBTYWZhcmkgY3Jvc3Mtb3JpZ2luIGlmcmFtZXMpLFxuICAgKiAqKnRoaXMgaW5mb3JtYXRpb24gbWF5IGJlIHdyb25nIGF0IGluaXRpYWxpemF0aW9uLCoqXG4gICAqIGFzIHRoZSBzdG9yYWdlIGNvdWxkIGZhbGxiYWNrIGZyb20gYGluZGV4ZWREQmAgdG8gYGxvY2FsU3RvcmFnZWBcbiAgICogb25seSBhZnRlciBhIGZpcnN0IHJlYWQgb3Igd3JpdGUgb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJucyBTdG9yYWdlIGVuZ2luZSB1c2VkXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvYmxvYi9tYXN0ZXIvZG9jcy9JTlRFUk9QRVJBQklMSVRZLm1kfVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpZiAodGhpcy5zdG9yYWdlTWFwLmJhY2tpbmdFbmdpbmUgPT09ICdpbmRleGVkREInKSB7fVxuICAgKi9cbiAgZ2V0IGJhY2tpbmdFbmdpbmUoKTogJ2luZGV4ZWREQicgfCAnbG9jYWxTdG9yYWdlJyB8wqAnbWVtb3J5JyB8ICd1bmtub3duJyB7XG5cbiAgICBpZiAodGhpcy5kYXRhYmFzZSBpbnN0YW5jZW9mIEluZGV4ZWREQkRhdGFiYXNlKSB7XG5cbiAgICAgIHJldHVybiAnaW5kZXhlZERCJztcblxuICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhYmFzZSBpbnN0YW5jZW9mIExvY2FsU3RvcmFnZURhdGFiYXNlKSB7XG5cbiAgICAgIHJldHVybiAnbG9jYWxTdG9yYWdlJztcblxuICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhYmFzZSBpbnN0YW5jZW9mIE1lbW9yeURhdGFiYXNlKSB7XG5cbiAgICAgIHJldHVybiAnbWVtb3J5JztcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHJldHVybiAndW5rbm93bic7XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBJbmZvIGFib3V0IGBpbmRleGVkREJgIGRhdGFiYXNlLiAqT25seSB1c2VmdWwgZm9yIGludGVyb3BlcmFiaWxpdHkuKlxuICAgKiBAcmV0dXJucyBgaW5kZXhlZERCYCBkYXRhYmFzZSBuYW1lLCBzdG9yZSBuYW1lIGFuZCBkYXRhYmFzZSB2ZXJzaW9uLlxuICAgKiAqKlZhbHVlcyB3aWxsIGJlIGVtcHR5IGlmIHRoZSBzdG9yYWdlIGlzIG5vdCBgaW5kZXhlZERCYCwqKlxuICAgKiAqKnNvIGl0IHNob3VsZCBiZSB1c2VkIGFmdGVyIGFuIGVuZ2luZSBjaGVjayoqLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2Jsb2IvbWFzdGVyL2RvY3MvSU5URVJPUEVSQUJJTElUWS5tZH1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaWYgKHRoaXMuc3RvcmFnZU1hcC5iYWNraW5nRW5naW5lID09PSAnaW5kZXhlZERCJykge1xuICAgKiAgIGNvbnN0IHsgZGF0YWJhc2UsIHN0b3JlLCB2ZXJzaW9uIH0gPSB0aGlzLnN0b3JhZ2VNYXAuYmFja2luZ1N0b3JlO1xuICAgKiB9XG4gICAqL1xuICBnZXQgYmFja2luZ1N0b3JlKCk6IHsgZGF0YWJhc2U6IHN0cmluZywgc3RvcmU6IHN0cmluZywgdmVyc2lvbjogbnVtYmVyIH0ge1xuXG4gICAgcmV0dXJuICh0aGlzLmRhdGFiYXNlIGluc3RhbmNlb2YgSW5kZXhlZERCRGF0YWJhc2UpID9cbiAgICAgIHRoaXMuZGF0YWJhc2UuYmFja2luZ1N0b3JlIDpcbiAgICAgIHsgZGF0YWJhc2U6ICcnLCBzdG9yZTogJycsIHZlcnNpb246IDAgfTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEluZm8gYWJvdXQgYGxvY2FsU3RvcmFnZWAgZmFsbGJhY2sgc3RvcmFnZS4gKk9ubHkgdXNlZnVsIGZvciBpbnRlcm9wZXJhYmlsaXR5LipcbiAgICogQHJldHVybnMgYGxvY2FsU3RvcmFnZWAgcHJlZml4LlxuICAgKiAqKlZhbHVlcyB3aWxsIGJlIGVtcHR5IGlmIHRoZSBzdG9yYWdlIGlzIG5vdCBgbG9jYWxTdG9yYWdlYCwqKlxuICAgKiAqKnNvIGl0IHNob3VsZCBiZSB1c2VkIGFmdGVyIGFuIGVuZ2luZSBjaGVjayoqLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2Jsb2IvbWFzdGVyL2RvY3MvSU5URVJPUEVSQUJJTElUWS5tZH1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaWYgKHRoaXMuc3RvcmFnZU1hcC5iYWNraW5nRW5naW5lID09PSAnbG9jYWxTdG9yYWdlJykge1xuICAgKiAgIGNvbnN0IHsgcHJlZml4IH0gPSB0aGlzLnN0b3JhZ2VNYXAuZmFsbGJhY2tCYWNraW5nU3RvcmU7XG4gICAqIH1cbiAgICovXG4gIGdldCBmYWxsYmFja0JhY2tpbmdTdG9yZSgpOiB7IHByZWZpeDogc3RyaW5nIH0ge1xuXG4gICAgcmV0dXJuICh0aGlzLmRhdGFiYXNlIGluc3RhbmNlb2YgTG9jYWxTdG9yYWdlRGF0YWJhc2UpID9cbiAgICAgIHsgcHJlZml4OiB0aGlzLmRhdGFiYXNlLnByZWZpeCB9IDpcbiAgICAgIHsgcHJlZml4OiAnJyB9O1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGl0ZW0gdmFsdWUgaW4gc3RvcmFnZS5cbiAgICogVGhlIHNpZ25hdHVyZSBoYXMgbWFueSBvdmVybG9hZHMgZHVlIHRvIHZhbGlkYXRpb24sICoqcGxlYXNlIHJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uLioqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvYmxvYi9tYXN0ZXIvZG9jcy9WQUxJREFUSU9OLm1kfVxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEBwYXJhbSBzY2hlbWEgT3B0aW9uYWwgSlNPTiBzY2hlbWEgdG8gdmFsaWRhdGUgdGhlIGRhdGFcbiAgICogQHJldHVybnMgVGhlIGl0ZW0ncyB2YWx1ZSBpZiB0aGUga2V5IGV4aXN0cywgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLCB3cmFwcGVkIGluIGEgUnhKUyBgT2JzZXJ2YWJsZWBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5zdG9yYWdlTWFwLmdldCgna2V5JywgeyB0eXBlOiAnc3RyaW5nJyB9KS5zdWJzY3JpYmUoKHJlc3VsdCkgPT4ge1xuICAgKiAgIHJlc3VsdDsgLy8gc3RyaW5nIG9yIHVuZGVmaW5lZFxuICAgKiB9KTtcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaW50ZXJmYWNlIFVzZXIge1xuICAgKiAgIGZpcnN0TmFtZTogc3RyaW5nO1xuICAgKiAgIGxhc3ROYW1lPzogc3RyaW5nO1xuICAgKiB9XG4gICAqXG4gICAqIGNvbnN0IHNjaGVtYSA9IHtcbiAgICogICB0eXBlOiAnb2JqZWN0JyxcbiAgICogICBwcm9wZXJ0aWVzOiB7XG4gICAqICAgICBmaXJzdE5hbWU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICogICAgIGxhc3ROYW1lOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAqICAgfSxcbiAgICogICByZXF1aXJlZDogWydmaXJzdE5hbWUnXVxuICAgKiB9O1xuICAgKlxuICAgKiB0aGlzLnN0b3JhZ2VNYXAuZ2V0PFVzZXI+KCd1c2VyJywgc2NoZW1hKS5zdWJzY3JpYmUoKHVzZXIpID0+IHtcbiAgICogICBpZiAodXNlcikge1xuICAgKiAgICAgdXNlci5maXJzdE5hbWU7XG4gICAqICAgfVxuICAgKiB9KTtcbiAgICovXG4gIGdldDxUID0gc3RyaW5nPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hU3RyaW5nKTogT2JzZXJ2YWJsZTxzdHJpbmcgfCB1bmRlZmluZWQ+O1xuICBnZXQ8VCA9IG51bWJlcj4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUludGVnZXLCoHwgSlNPTlNjaGVtYU51bWJlcik6IE9ic2VydmFibGU8bnVtYmVyIHwgdW5kZWZpbmVkPjtcbiAgZ2V0PFQgPSBib29sZWFuPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQm9vbGVhbik6IE9ic2VydmFibGU8Ym9vbGVhbiB8IHVuZGVmaW5lZD47XG4gIGdldDxUID0gc3RyaW5nW10+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFBcnJheU9mPEpTT05TY2hlbWFTdHJpbmc+KTogT2JzZXJ2YWJsZTxzdHJpbmdbXSB8IHVuZGVmaW5lZD47XG4gIGdldDxUID0gbnVtYmVyW10+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFBcnJheU9mPEpTT05TY2hlbWFJbnRlZ2VywqB8IEpTT05TY2hlbWFOdW1iZXI+KTogT2JzZXJ2YWJsZTxudW1iZXJbXSB8IHVuZGVmaW5lZD47XG4gIGdldDxUID0gYm9vbGVhbltdPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQXJyYXlPZjxKU09OU2NoZW1hQm9vbGVhbj4pOiBPYnNlcnZhYmxlPGJvb2xlYW5bXSB8IHVuZGVmaW5lZD47XG4gIGdldDxUID0gYW55PihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hKTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjtcbiAgZ2V0PFQgPSB1bmtub3duPihrZXk6IHN0cmluZywgc2NoZW1hPzogSlNPTlNjaGVtYSk6IE9ic2VydmFibGU8dW5rbm93bj47XG4gIGdldDxUID0gYW55PihrZXk6IHN0cmluZywgc2NoZW1hPzogSlNPTlNjaGVtYSkge1xuXG4gICAgLyogR2V0IHRoZSBkYXRhIGluIHN0b3JhZ2UgKi9cbiAgICByZXR1cm4gdGhpcy5kYXRhYmFzZS5nZXQ8VD4oa2V5KS5waXBlKFxuICAgICAgLyogQ2hlY2sgaWYgYGluZGV4ZWREYmAgaXMgYnJva2VuICovXG4gICAgICB0aGlzLmNhdGNoSURCQnJva2VuKCgpID0+IHRoaXMuZGF0YWJhc2UuZ2V0PFQ+KGtleSkpLFxuICAgICAgbWVyZ2VNYXAoKGRhdGEpID0+IHtcblxuICAgICAgICAvKiBObyBuZWVkIHRvIHZhbGlkYXRlIGlmIHRoZSBkYXRhIGlzIGVtcHR5ICovXG4gICAgICAgIGlmICgoZGF0YSA9PT0gdW5kZWZpbmVkKSB8fCAoZGF0YSA9PT0gbnVsbCkpIHtcblxuICAgICAgICAgIHJldHVybiBvZih1bmRlZmluZWQpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoc2NoZW1hKSB7XG5cbiAgICAgICAgICAvKiBWYWxpZGF0ZSBkYXRhIGFnYWluc3QgYSBKU09OIHNjaGVtYSBpZiBwcm92aWRlZCAqL1xuICAgICAgICAgIGlmICghdGhpcy5qc29uVmFsaWRhdG9yLnZhbGlkYXRlKGRhdGEsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKG5ldyBWYWxpZGF0aW9uRXJyb3IoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyogRGF0YSBoYXZlIGJlZW4gY2hlY2tlZCwgc28gaXQncyBPSyB0byBjYXN0ICovXG4gICAgICAgICAgcmV0dXJuIG9mKGRhdGEgYXMgVCB8IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIENhc3QgdG8gdW5rbm93biBhcyB0aGUgZGF0YSB3YXNuJ3QgY2hlY2tlZCAqL1xuICAgICAgICByZXR1cm4gb2YoZGF0YSBhcyB1bmtub3duKTtcblxuICAgICAgfSksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhbiBpdGVtIGluIHN0b3JhZ2UuXG4gICAqIE5vdGUgdGhhdCBzZXR0aW5nIGBudWxsYCBvciBgdW5kZWZpbmVkYCB3aWxsIHJlbW92ZSB0aGUgaXRlbSB0byBhdm9pZCBzb21lIGJyb3dzZXJzIGlzc3Vlcy5cbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgKiBAcGFyYW0gZGF0YSBUaGUgaXRlbSdzIHZhbHVlXG4gICAqIEBwYXJhbSBzY2hlbWEgT3B0aW9uYWwgSlNPTiBzY2hlbWEgdG8gdmFsaWRhdGUgdGhlIGRhdGFcbiAgICogQHJldHVybnMgQSBSeEpTIGBPYnNlcnZhYmxlYCB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLnN0b3JhZ2VNYXAuc2V0KCdrZXknLCAndmFsdWUnKS5zdWJzY3JpYmUoKCkgPT4ge30pO1xuICAgKi9cbiAgc2V0KGtleTogc3RyaW5nLCBkYXRhOiBhbnksIHNjaGVtYT86IEpTT05TY2hlbWEpOiBPYnNlcnZhYmxlPHVuZGVmaW5lZD4ge1xuXG4gICAgLyogU3RvcmluZyBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaXMgdXNlbGVzcyBhbmQgY2FuIGNhdXNlIGlzc3VlcyBpbiBgaW5kZXhlZERiYCBpbiBzb21lIGJyb3dzZXJzLFxuICAgICAqIHNvIHJlbW92aW5nIGl0ZW0gaW5zdGVhZCBmb3IgYWxsIHN0b3JhZ2VzIHRvIGhhdmUgYSBjb25zaXN0ZW50IEFQSSAqL1xuICAgIGlmICgoZGF0YSA9PT0gdW5kZWZpbmVkKSB8fCAoZGF0YSA9PT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbGV0ZShrZXkpO1xuICAgIH1cblxuICAgIC8qIFZhbGlkYXRlIGRhdGEgYWdhaW5zdCBhIEpTT04gc2NoZW1hIGlmIHByb3ZpZGVkICovXG4gICAgaWYgKHNjaGVtYSAmJiAhdGhpcy5qc29uVmFsaWRhdG9yLnZhbGlkYXRlKGRhdGEsIHNjaGVtYSkpIHtcbiAgICAgIHJldHVybiB0aHJvd0Vycm9yKG5ldyBWYWxpZGF0aW9uRXJyb3IoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YWJhc2Uuc2V0KGtleSwgZGF0YSlcbiAgICAgIC8qIENhdGNoIGlmIGBpbmRleGVkRGJgIGlzIGJyb2tlbiAqL1xuICAgICAgLnBpcGUodGhpcy5jYXRjaElEQkJyb2tlbigoKSA9PiB0aGlzLmRhdGFiYXNlLnNldChrZXksIGRhdGEpKSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYW4gaXRlbSBpbiBzdG9yYWdlXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHJldHVybnMgQSBSeEpTIGBPYnNlcnZhYmxlYCB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLnN0b3JhZ2VNYXAuZGVsZXRlKCdrZXknKS5zdWJzY3JpYmUoKCkgPT4ge30pO1xuICAgKi9cbiAgZGVsZXRlKGtleTogc3RyaW5nKTogT2JzZXJ2YWJsZTx1bmRlZmluZWQ+IHtcblxuICAgIHJldHVybiB0aGlzLmRhdGFiYXNlLmRlbGV0ZShrZXkpXG4gICAgICAvKiBDYXRjaCBpZiBgaW5kZXhlZERiYCBpcyBicm9rZW4gKi9cbiAgICAgIC5waXBlKHRoaXMuY2F0Y2hJREJCcm9rZW4oKCkgPT4gdGhpcy5kYXRhYmFzZS5kZWxldGUoa2V5KSkpO1xuXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGFsbCBpdGVtcyBpbiBzdG9yYWdlXG4gICAqIEByZXR1cm5zIEEgUnhKUyBgT2JzZXJ2YWJsZWAgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5zdG9yYWdlTWFwLmNsZWFyKCkuc3Vic2NyaWJlKCgpID0+IHt9KTtcbiAgICovXG4gIGNsZWFyKCk6IE9ic2VydmFibGU8dW5kZWZpbmVkPiB7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhYmFzZS5jbGVhcigpXG4gICAgICAvKiBDYXRjaCBpZiBgaW5kZXhlZERiYCBpcyBicm9rZW4gKi9cbiAgICAgIC5waXBlKHRoaXMuY2F0Y2hJREJCcm9rZW4oKCkgPT4gdGhpcy5kYXRhYmFzZS5jbGVhcigpKSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGtleXMgc3RvcmVkIGluIHN0b3JhZ2UuIE5vdGUgKip0aGlzIGlzIGFuICppdGVyYXRpbmcqIGBPYnNlcnZhYmxlYCoqOlxuICAgKiAqIGlmIHRoZXJlIGlzIG5vIGtleSwgdGhlIGBuZXh0YCBjYWxsYmFjayB3aWxsIG5vdCBiZSBpbnZva2VkLFxuICAgKiAqIGlmIHlvdSBuZWVkIHRvIHdhaXQgdGhlIHdob2xlIG9wZXJhdGlvbiB0byBlbmQsIGJlIHN1cmUgdG8gYWN0IGluIHRoZSBgY29tcGxldGVgIGNhbGxiYWNrLFxuICAgKiBhcyB0aGlzIGBPYnNlcnZhYmxlYCBjYW4gZW1pdCBzZXZlcmFsIHZhbHVlcyBhbmQgc28gd2lsbCBpbnZva2UgdGhlIGBuZXh0YCBjYWxsYmFjayBzZXZlcmFsIHRpbWVzLlxuICAgKiBAcmV0dXJucyBBIGxpc3Qgb2YgdGhlIGtleXMgd3JhcHBlZCBpbiBhIFJ4SlMgYE9ic2VydmFibGVgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMuc3RvcmFnZU1hcC5rZXlzKCkuc3Vic2NyaWJlKHtcbiAgICogICBuZXh0OiAoa2V5KSA9PiB7IGNvbnNvbGUubG9nKGtleSk7IH0sXG4gICAqICAgY29tcGxldGU6ICgpID0+IHsgY29uc29sZS5sb2coJ0RvbmUnKTsgfSxcbiAgICogfSk7XG4gICAqL1xuICBrZXlzKCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhYmFzZS5rZXlzKClcbiAgICAgIC8qIENhdGNoIGlmIGBpbmRleGVkRGJgIGlzIGJyb2tlbiAqL1xuICAgICAgLnBpcGUodGhpcy5jYXRjaElEQkJyb2tlbigoKSA9PiB0aGlzLmRhdGFiYXNlLmtleXMoKSkpO1xuXG4gIH1cblxuICAvKipcbiAgICogVGVsbHMgaWYgYSBrZXkgZXhpc3RzIGluIHN0b3JhZ2VcbiAgICogQHJldHVybnMgQSBSeEpTIGBPYnNlcnZhYmxlYCB0ZWxsaW5nIGlmIHRoZSBrZXkgZXhpc3RzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMuc3RvcmFnZU1hcC5oYXMoJ2tleScpLnN1YnNjcmliZSgoaGFzS2V5KSA9PiB7XG4gICAqICAgaWYgKGhhc0tleSkge31cbiAgICogfSk7XG4gICAqL1xuICBoYXMoa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcblxuICAgIHJldHVybiB0aGlzLmRhdGFiYXNlLmhhcyhrZXkpXG4gICAgICAvKiBDYXRjaCBpZiBgaW5kZXhlZERiYCBpcyBicm9rZW4gKi9cbiAgICAgIC5waXBlKHRoaXMuY2F0Y2hJREJCcm9rZW4oKCkgPT4gdGhpcy5kYXRhYmFzZS5oYXMoa2V5KSkpO1xuXG4gIH1cblxuICAvKipcbiAgICogUnhKUyBvcGVyYXRvciB0byBjYXRjaCBpZiBgaW5kZXhlZERCYCBpcyBicm9rZW5cbiAgICogQHBhcmFtIG9wZXJhdGlvbkNhbGxiYWNrIENhbGxiYWNrIHdpdGggdGhlIG9wZXJhdGlvbiB0byByZWRvXG4gICAqL1xuICBwcm90ZWN0ZWQgY2F0Y2hJREJCcm9rZW48VD4ob3BlcmF0aW9uQ2FsbGJhY2s6ICgpID0+IE9ic2VydmFibGU8VD4pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFQ+IHtcblxuICAgIHJldHVybiBjYXRjaEVycm9yKChlcnJvcikgPT4ge1xuXG4gICAgICAvKiBDaGVjayBpZiBgaW5kZXhlZERCYCBpcyBicm9rZW4gYmFzZWQgb24gZXJyb3IgbWVzc2FnZSAodGhlIHNwZWNpZmljIGVycm9yIGNsYXNzIHNlZW1zIHRvIGJlIGxvc3QgaW4gdGhlIHByb2Nlc3MpICovXG4gICAgICBpZiAoKGVycm9yICE9PSB1bmRlZmluZWQpICYmIChlcnJvciAhPT0gbnVsbCkgJiYgKGVycm9yLm1lc3NhZ2UgPT09IElEQl9CUk9LRU5fRVJST1IpKSB7XG5cbiAgICAgICAgLyogV2hlbiBzdG9yYWdlIGlzIGZ1bGx5IGRpc2FibGVkIGluIGJyb3dzZXIgKHZpYSB0aGUgXCJCbG9jayBhbGwgY29va2llc1wiIG9wdGlvbiksXG4gICAgICAgICAqIGp1c3QgdHJ5aW5nIHRvIGNoZWNrIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIGNhdXNlcyBhIHNlY3VyaXR5IGV4Y2VwdGlvbi5cbiAgICAgICAgICogUHJldmVudHMgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9pc3N1ZXMvMTE4XG4gICAgICAgICAqL1xuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgaWYgKCdnZXRJdGVtJyBpbiBsb2NhbFN0b3JhZ2UpIHtcblxuICAgICAgICAgICAgLyogRmFsbGJhY2sgdG8gYGxvY2FsU3RvcmFnZWAgaWYgYXZhaWxhYmxlICovXG4gICAgICAgICAgICB0aGlzLmRhdGFiYXNlID0gbmV3IExvY2FsU3RvcmFnZURhdGFiYXNlKHRoaXMuTFNQcmVmaXgsIHRoaXMub2xkUHJlZml4KTtcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8qIEZhbGxiYWNrIHRvIG1lbW9yeSBzdG9yYWdlIG90aGVyd2lzZSAqL1xuICAgICAgICAgICAgdGhpcy5kYXRhYmFzZSA9IG5ldyBNZW1vcnlEYXRhYmFzZSgpO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gY2F0Y2gge1xuXG4gICAgICAgICAgLyogRmFsbGJhY2sgdG8gbWVtb3J5IHN0b3JhZ2Ugb3RoZXJ3aXNlICovXG4gICAgICAgICAgdGhpcy5kYXRhYmFzZSA9IG5ldyBNZW1vcnlEYXRhYmFzZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvKiBSZWRvIHRoZSBvcGVyYXRpb24gKi9cbiAgICAgICAgcmV0dXJuIG9wZXJhdGlvbkNhbGxiYWNrKCk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLyogT3RoZXJ3aXNlLCByZXRocm93IHRoZSBlcnJvciAqL1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvcik7XG5cbiAgICAgIH1cblxuICAgIH0pO1xuXG4gIH1cblxufVxuIl19