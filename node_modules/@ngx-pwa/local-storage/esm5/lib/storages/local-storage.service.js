import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { mapTo, toArray, map } from 'rxjs/operators';
import { StorageMap } from './storage-map.service';
import * as i0 from "@angular/core";
import * as i1 from "./storage-map.service";
var LocalStorage = /** @class */ (function () {
    /* Use the `StorageMap` service to avoid code duplication */
    function LocalStorage(storageMap) {
        this.storageMap = storageMap;
    }
    Object.defineProperty(LocalStorage.prototype, "size", {
        /**
         * Number of items in storage
         * @deprecated Use `.length`, or use `.size` via the new `StorageMap` service. Will be removed in v9.
         */
        get: function () {
            return this.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LocalStorage.prototype, "length", {
        /**
         * Number of items in storage wrapped in an `Observable`
         *
         * @example
         * this.localStorage.length.subscribe((length) => {
         *   console.log(length);
         * });
         */
        get: function () {
            return this.storageMap.size;
        },
        enumerable: true,
        configurable: true
    });
    LocalStorage.prototype.getItem = function (key, schema) {
        if (schema) {
            /* Backward compatibility with version <= 7 */
            var schemaFinal = ('schema' in schema) ? schema.schema : schema;
            return this.storageMap.get(key, schemaFinal).pipe(
            /* Transform `undefined` into `null` to align with `localStorage` API */
            map(function (value) { return (value !== undefined) ? value : null; }));
        }
        else {
            return this.storageMap.get(key).pipe(
            /* Transform `undefined` into `null` to align with `localStorage` API */
            map(function (value) { return (value !== undefined) ? value : null; }));
        }
    };
    /**
     * Set an item in storage.
     * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.
     * @param key The item's key
     * @param data The item's value
     * @param schema Optional JSON schema to validate the data
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.localStorage.set('key', 'value').subscribe(() => {});
     */
    LocalStorage.prototype.setItem = function (key, data, schema) {
        return this.storageMap.set(key, data, schema).pipe(
        /* Transform `undefined` into `true` for backward compatibility with v7 */
        mapTo(true));
    };
    /**
     * Delete an item in storage
     * @param key The item's key
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.localStorage.delete('key').subscribe(() => {});
     */
    LocalStorage.prototype.removeItem = function (key) {
        return this.storageMap.delete(key).pipe(
        /* Transform `undefined` into `true` for backward compatibility with v7 */
        mapTo(true));
    };
    /**
     * Delete all items in storage
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.localStorage.clear().subscribe(() => {});
     */
    LocalStorage.prototype.clear = function () {
        return this.storageMap.clear().pipe(
        /* Transform `undefined` into `true` for backward compatibility with v7 */
        mapTo(true));
    };
    /**
     * Get all keys stored in storage
     * @returns A list of the keys wrapped in a RxJS `Observable`
     * @deprecated Moved to `StorageMap` service. Will be removed in v9.
     * Note that while this method was giving you all keys at once in an array,
     * the new `keys()` method in `StorageMap` service will *iterate* on each key.
     */
    LocalStorage.prototype.keys = function () {
        return this.storageMap.keys().pipe(
        /* Backward compatibility with v7: transform iterating `Observable` to a single array value */
        toArray());
    };
    /**
     * Tells if a key exists in storage
     * @returns A RxJS `Observable` telling if the key exists
     * @deprecated Moved to `StorageMap` service. Will be removed in v9.
     */
    LocalStorage.prototype.has = function (key) {
        return this.storageMap.has(key);
    };
    /**
     * Set an item in storage, and auto-subscribe
     * @param key The item's key
     * @param data The item's value
     * **WARNING: should be avoided in most cases, use this method only if these conditions are fulfilled:**
     * - you don't need to manage the error callback (errors will silently fail),
     * - you don't need to wait the operation to finish before the next one (remember, it's asynchronous).
     * @deprecated Promoted bad practices. Will be removed in v9.
     */
    LocalStorage.prototype.setItemSubscribe = function (key, data) {
        this.setItem(key, data).subscribe({
            next: function () { },
            error: function () { },
        });
    };
    /**
     * Delete an item in storage, and auto-subscribe
     * @param key The item's key
     * **WARNING: should be avoided in most cases, use this method only if these conditions are fulfilled:**
     * - you don't need to manage the error callback (errors will silently fail),
     * - you don't need to wait the operation to finish before the next one (remember, it's asynchronous).
     * @deprecated Promoted bad practices. Will be removed in v9.
     */
    LocalStorage.prototype.removeItemSubscribe = function (key) {
        this.removeItem(key).subscribe({
            next: function () { },
            error: function () { },
        });
    };
    /**
     * Delete all items in storage, and auto-subscribe
     * **WARNING: should be avoided in most cases, use this method only if these conditions are fulfilled:**
     * - you don't need to manage the error callback (errors will silently fail),
     * - you don't need to wait the operation to finish before the next one (remember, it's asynchronous).
     * @deprecated Promoted bad practices. Will be removed in v9.
     */
    LocalStorage.prototype.clearSubscribe = function () {
        this.clear().subscribe({
            next: function () { },
            error: function () { },
        });
    };
    LocalStorage.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function LocalStorage_Factory() { return new LocalStorage(i0.ɵɵinject(i1.StorageMap)); }, token: LocalStorage, providedIn: "root" });
    LocalStorage = tslib_1.__decorate([
        Injectable({
            providedIn: 'root'
        }),
        tslib_1.__metadata("design:paramtypes", [StorageMap])
    ], LocalStorage);
    return LocalStorage;
}());
export { LocalStorage };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9jYWwtc3RvcmFnZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neC1wd2EvbG9jYWwtc3RvcmFnZS8iLCJzb3VyY2VzIjpbImxpYi9zdG9yYWdlcy9sb2NhbC1zdG9yYWdlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFM0MsT0FBTyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFckQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHVCQUF1QixDQUFDOzs7QUFvQm5EO0lBMEJFLDREQUE0RDtJQUM1RCxzQkFBc0IsVUFBc0I7UUFBdEIsZUFBVSxHQUFWLFVBQVUsQ0FBWTtJQUFHLENBQUM7SUFyQmhELHNCQUFJLDhCQUFJO1FBSlI7OztXQUdHO2FBQ0g7WUFFRSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7UUFFckIsQ0FBQzs7O09BQUE7SUFVRCxzQkFBSSxnQ0FBTTtRQVJWOzs7Ozs7O1dBT0c7YUFDSDtZQUVFLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7UUFFOUIsQ0FBQzs7O09BQUE7SUFrREQsOEJBQU8sR0FBUCxVQUFpQixHQUFXLEVBQUUsTUFBd0Q7UUFFcEYsSUFBSSxNQUFNLEVBQUU7WUFFViw4Q0FBOEM7WUFDOUMsSUFBTSxXQUFXLEdBQWUsQ0FBQyxRQUFRLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztZQUU5RSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFJLEdBQUcsRUFBRSxXQUFXLENBQUMsQ0FBQyxJQUFJO1lBQ2xELHdFQUF3RTtZQUN4RSxHQUFHLENBQUMsVUFBQyxLQUFLLElBQUssT0FBQSxDQUFDLEtBQUssS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQXBDLENBQW9DLENBQUMsQ0FDckQsQ0FBQztTQUVIO2FBQU07WUFFTCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUk7WUFDbEMsd0VBQXdFO1lBQ3hFLEdBQUcsQ0FBQyxVQUFDLEtBQUssSUFBSyxPQUFBLENBQUMsS0FBSyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBcEMsQ0FBb0MsQ0FBQyxDQUNyRCxDQUFDO1NBRUg7SUFFSCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNILDhCQUFPLEdBQVAsVUFBUSxHQUFXLEVBQUUsSUFBUyxFQUFFLE1BQW1CO1FBRWpELE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQyxJQUFJO1FBQ2hELDBFQUEwRTtRQUMxRSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQ1osQ0FBQztJQUVKLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsaUNBQVUsR0FBVixVQUFXLEdBQVc7UUFFcEIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJO1FBQ3JDLDBFQUEwRTtRQUMxRSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQ1osQ0FBQztJQUVKLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCw0QkFBSyxHQUFMO1FBRUUsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDLElBQUk7UUFDakMsMEVBQTBFO1FBQzFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FDWixDQUFDO0lBRUosQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILDJCQUFJLEdBQUo7UUFFRSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSTtRQUNoQyw4RkFBOEY7UUFDOUYsT0FBTyxFQUFFLENBQ1YsQ0FBQztJQUVKLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsMEJBQUcsR0FBSCxVQUFJLEdBQVc7UUFFYixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRWxDLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNILHVDQUFnQixHQUFoQixVQUFpQixHQUFXLEVBQUUsSUFBd0M7UUFFcEUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDO1lBQ2hDLElBQUksRUFBRSxjQUFPLENBQUM7WUFDZCxLQUFLLEVBQUUsY0FBTyxDQUFDO1NBQ2hCLENBQUMsQ0FBQztJQUVMLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0YsMENBQW1CLEdBQW5CLFVBQW9CLEdBQVc7UUFFOUIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUFTLENBQUM7WUFDN0IsSUFBSSxFQUFFLGNBQU8sQ0FBQztZQUNkLEtBQUssRUFBRSxjQUFPLENBQUM7U0FDaEIsQ0FBQyxDQUFDO0lBRUwsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILHFDQUFjLEdBQWQ7UUFFRSxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsU0FBUyxDQUFDO1lBQ3JCLElBQUksRUFBRSxjQUFPLENBQUM7WUFDZCxLQUFLLEVBQUUsY0FBTyxDQUFDO1NBQ2hCLENBQUMsQ0FBQztJQUVMLENBQUM7O0lBbE9VLFlBQVk7UUFIeEIsVUFBVSxDQUFDO1lBQ1YsVUFBVSxFQUFFLE1BQU07U0FDbkIsQ0FBQztpREE0QmtDLFVBQVU7T0EzQmpDLFlBQVksQ0FvT3hCO3VCQTVQRDtDQTRQQyxBQXBPRCxJQW9PQztTQXBPWSxZQUFZIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwVG8sIHRvQXJyYXksIG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgU3RvcmFnZU1hcCB9IGZyb20gJy4vc3RvcmFnZS1tYXAuc2VydmljZSc7XG5pbXBvcnQgeyBKU09OU2NoZW1hLCBKU09OU2NoZW1hQm9vbGVhbiwgSlNPTlNjaGVtYUludGVnZXIsIEpTT05TY2hlbWFOdW1iZXIsIEpTT05TY2hlbWFTdHJpbmcsIEpTT05TY2hlbWFBcnJheU9mIH0gZnJvbSAnLi4vdmFsaWRhdGlvbic7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHY5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTFNHZXRJdGVtT3B0aW9ucyB7XG5cbiAgLyoqXG4gICAqIFN1YnNldCBvZiB0aGUgSlNPTiBTY2hlbWEgc3RhbmRhcmQuXG4gICAqIFR5cGVzIGFyZSBlbmZvcmNlZCB0byB2YWxpZGF0ZSBldmVyeXRoaW5nOiBlYWNoIHZhbHVlICoqbXVzdCoqIGhhdmUgYSBgdHlwZWAuXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvYmxvYi9tYXN0ZXIvZG9jcy9WQUxJREFUSU9OLm1kfVxuICAgKi9cbiAgc2NoZW1hPzogSlNPTlNjaGVtYSB8IG51bGw7XG5cbn1cblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgTG9jYWxTdG9yYWdlIHtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIGl0ZW1zIGluIHN0b3JhZ2VcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGAubGVuZ3RoYCwgb3IgdXNlIGAuc2l6ZWAgdmlhIHRoZSBuZXcgYFN0b3JhZ2VNYXBgIHNlcnZpY2UuIFdpbGwgYmUgcmVtb3ZlZCBpbiB2OS5cbiAgICovXG4gIGdldCBzaXplKCk6IE9ic2VydmFibGU8bnVtYmVyPiB7XG5cbiAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgaXRlbXMgaW4gc3RvcmFnZSB3cmFwcGVkIGluIGFuIGBPYnNlcnZhYmxlYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLmxvY2FsU3RvcmFnZS5sZW5ndGguc3Vic2NyaWJlKChsZW5ndGgpID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhsZW5ndGgpO1xuICAgKiB9KTtcbiAgICovXG4gIGdldCBsZW5ndGgoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcblxuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VNYXAuc2l6ZTtcblxuICB9XG5cbiAgLyogVXNlIHRoZSBgU3RvcmFnZU1hcGAgc2VydmljZSB0byBhdm9pZCBjb2RlIGR1cGxpY2F0aW9uICovXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBzdG9yYWdlTWFwOiBTdG9yYWdlTWFwKSB7fVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaXRlbSB2YWx1ZSBpbiBzdG9yYWdlLlxuICAgKiBUaGUgc2lnbmF0dXJlIGhhcyBtYW55IG92ZXJsb2FkcyBkdWUgdG8gdmFsaWRhdGlvbiwgKipwbGVhc2UgcmVmZXIgdG8gdGhlIGRvY3VtZW50YXRpb24uKipcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9ibG9iL21hc3Rlci9kb2NzL1ZBTElEQVRJT04ubWR9XG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHBhcmFtIHNjaGVtYSBPcHRpb25hbCBKU09OIHNjaGVtYSB0byB2YWxpZGF0ZSB0aGUgZGF0YS5cbiAgICogKipOb3RlIHlvdSBtdXN0IHBhc3MgdGhlIHNjaGVtYSBkaXJlY3RseSBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LioqXG4gICAqICoqUGFzc2luZyB0aGUgc2NoZW1hIGluIGFuIG9iamVjdCBgeyBzY2hlbWEgfWAgaXMgZGVwcmVjYXRlZCBhbmQgb25seSBoZXJlKipcbiAgICogKipmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eTogaXQgd2lsbCBiZSByZW1vdmVkIGluIHY5LioqXG4gICAqIEByZXR1cm5zIFRoZSBpdGVtJ3MgdmFsdWUgaWYgdGhlIGtleSBleGlzdHMsIGBudWxsYCBvdGhlcndpc2UsIHdyYXBwZWQgaW4gYSBSeEpTIGBPYnNlcnZhYmxlYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLmxvY2FsU3RvcmFnZS5nZXQoJ2tleScsIHsgdHlwZTogJ3N0cmluZycgfSkuc3Vic2NyaWJlKChyZXN1bHQpID0+IHtcbiAgICogICByZXN1bHQ7IC8vIHN0cmluZyBvciBudWxsXG4gICAqIH0pO1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbnRlcmZhY2UgVXNlciB7XG4gICAqICAgZmlyc3ROYW1lOiBzdHJpbmc7XG4gICAqICAgbGFzdE5hbWU/OiBzdHJpbmc7XG4gICAqIH1cbiAgICpcbiAgICogY29uc3Qgc2NoZW1hID0ge1xuICAgKiAgIHR5cGU6ICdvYmplY3QnLFxuICAgKiAgIHByb3BlcnRpZXM6IHtcbiAgICogICAgIGZpcnN0TmFtZTogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgKiAgICAgbGFzdE5hbWU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICogICB9LFxuICAgKiAgIHJlcXVpcmVkOiBbJ2ZpcnN0TmFtZSddXG4gICAqIH07XG4gICAqXG4gICAqIHRoaXMubG9jYWxTdG9yYWdlLmdldDxVc2VyPigndXNlcicsIHNjaGVtYSkuc3Vic2NyaWJlKCh1c2VyKSA9PiB7XG4gICAqICAgaWYgKHVzZXIpIHtcbiAgICogICAgIHVzZXIuZmlyc3ROYW1lO1xuICAgKiAgIH1cbiAgICogfSk7XG4gICAqL1xuICBnZXRJdGVtPFQgPSBzdHJpbmc+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFTdHJpbmcpOiBPYnNlcnZhYmxlPHN0cmluZyB8IG51bGw+O1xuICBnZXRJdGVtPFQgPSBudW1iZXI+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFJbnRlZ2VywqB8IEpTT05TY2hlbWFOdW1iZXIpOiBPYnNlcnZhYmxlPG51bWJlciB8IG51bGw+O1xuICBnZXRJdGVtPFQgPSBib29sZWFuPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQm9vbGVhbik6IE9ic2VydmFibGU8Ym9vbGVhbiB8IG51bGw+O1xuICBnZXRJdGVtPFQgPSBzdHJpbmdbXT4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUFycmF5T2Y8SlNPTlNjaGVtYVN0cmluZz4pOiBPYnNlcnZhYmxlPHN0cmluZ1tdIHwgbnVsbD47XG4gIGdldEl0ZW08VCA9IG51bWJlcltdPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQXJyYXlPZjxKU09OU2NoZW1hSW50ZWdlcsKgfCBKU09OU2NoZW1hTnVtYmVyPik6IE9ic2VydmFibGU8bnVtYmVyW10gfCBudWxsPjtcbiAgZ2V0SXRlbTxUID0gYm9vbGVhbltdPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQXJyYXlPZjxKU09OU2NoZW1hQm9vbGVhbj4pOiBPYnNlcnZhYmxlPGJvb2xlYW5bXSB8IG51bGw+O1xuICBnZXRJdGVtPFQgPSBhbnk+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWEgfCB7IHNjaGVtYTogSlNPTlNjaGVtYSB9KTogT2JzZXJ2YWJsZTxUIHwgbnVsbD47XG4gIGdldEl0ZW08VCA9IHVua25vd24+KGtleTogc3RyaW5nLCBzY2hlbWE/OiBKU09OU2NoZW1hKTogT2JzZXJ2YWJsZTx1bmtub3duPjtcbiAgZ2V0SXRlbTxUID0gYW55PihrZXk6IHN0cmluZywgc2NoZW1hPzogSlNPTlNjaGVtYSB8IHsgc2NoZW1hOiBKU09OU2NoZW1hIH0gfCB1bmRlZmluZWQpIHtcblxuICAgIGlmIChzY2hlbWEpIHtcblxuICAgICAgLyogQmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIHZlcnNpb24gPD0gNyAqL1xuICAgICAgY29uc3Qgc2NoZW1hRmluYWw6IEpTT05TY2hlbWEgPSAoJ3NjaGVtYScgaW4gc2NoZW1hKSA/IHNjaGVtYS5zY2hlbWEgOiBzY2hlbWE7XG5cbiAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2VNYXAuZ2V0PFQ+KGtleSwgc2NoZW1hRmluYWwpLnBpcGUoXG4gICAgICAgIC8qIFRyYW5zZm9ybSBgdW5kZWZpbmVkYCBpbnRvIGBudWxsYCB0byBhbGlnbiB3aXRoIGBsb2NhbFN0b3JhZ2VgIEFQSSAqL1xuICAgICAgICBtYXAoKHZhbHVlKSA9PiAodmFsdWUgIT09IHVuZGVmaW5lZCkgPyB2YWx1ZSA6IG51bGwpLFxuICAgICAgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2VNYXAuZ2V0KGtleSkucGlwZShcbiAgICAgICAgLyogVHJhbnNmb3JtIGB1bmRlZmluZWRgIGludG8gYG51bGxgIHRvIGFsaWduIHdpdGggYGxvY2FsU3RvcmFnZWAgQVBJICovXG4gICAgICAgIG1hcCgodmFsdWUpID0+ICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSA/IHZhbHVlIDogbnVsbCksXG4gICAgICApO1xuXG4gICAgfVxuXG4gIH1cblxuICAvKipcbiAgICogU2V0IGFuIGl0ZW0gaW4gc3RvcmFnZS5cbiAgICogTm90ZSB0aGF0IHNldHRpbmcgYG51bGxgIG9yIGB1bmRlZmluZWRgIHdpbGwgcmVtb3ZlIHRoZSBpdGVtIHRvIGF2b2lkIHNvbWUgYnJvd3NlcnMgaXNzdWVzLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEBwYXJhbSBkYXRhIFRoZSBpdGVtJ3MgdmFsdWVcbiAgICogQHBhcmFtIHNjaGVtYSBPcHRpb25hbCBKU09OIHNjaGVtYSB0byB2YWxpZGF0ZSB0aGUgZGF0YVxuICAgKiBAcmV0dXJucyBBIFJ4SlMgYE9ic2VydmFibGVgIHRvIHdhaXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMubG9jYWxTdG9yYWdlLnNldCgna2V5JywgJ3ZhbHVlJykuc3Vic2NyaWJlKCgpID0+IHt9KTtcbiAgICovXG4gIHNldEl0ZW0oa2V5OiBzdHJpbmcsIGRhdGE6IGFueSwgc2NoZW1hPzogSlNPTlNjaGVtYSk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuXG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZU1hcC5zZXQoa2V5LCBkYXRhLCBzY2hlbWEpLnBpcGUoXG4gICAgICAvKiBUcmFuc2Zvcm0gYHVuZGVmaW5lZGAgaW50byBgdHJ1ZWAgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCB2NyAqL1xuICAgICAgbWFwVG8odHJ1ZSksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhbiBpdGVtIGluIHN0b3JhZ2VcbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgKiBAcmV0dXJucyBBIFJ4SlMgYE9ic2VydmFibGVgIHRvIHdhaXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMubG9jYWxTdG9yYWdlLmRlbGV0ZSgna2V5Jykuc3Vic2NyaWJlKCgpID0+IHt9KTtcbiAgICovXG4gIHJlbW92ZUl0ZW0oa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcblxuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VNYXAuZGVsZXRlKGtleSkucGlwZShcbiAgICAgIC8qIFRyYW5zZm9ybSBgdW5kZWZpbmVkYCBpbnRvIGB0cnVlYCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIHY3ICovXG4gICAgICBtYXBUbyh0cnVlKSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGFsbCBpdGVtcyBpbiBzdG9yYWdlXG4gICAqIEByZXR1cm5zIEEgUnhKUyBgT2JzZXJ2YWJsZWAgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5sb2NhbFN0b3JhZ2UuY2xlYXIoKS5zdWJzY3JpYmUoKCkgPT4ge30pO1xuICAgKi9cbiAgY2xlYXIoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG5cbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlTWFwLmNsZWFyKCkucGlwZShcbiAgICAgIC8qIFRyYW5zZm9ybSBgdW5kZWZpbmVkYCBpbnRvIGB0cnVlYCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIHY3ICovXG4gICAgICBtYXBUbyh0cnVlKSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBrZXlzIHN0b3JlZCBpbiBzdG9yYWdlXG4gICAqIEByZXR1cm5zIEEgbGlzdCBvZiB0aGUga2V5cyB3cmFwcGVkIGluIGEgUnhKUyBgT2JzZXJ2YWJsZWBcbiAgICogQGRlcHJlY2F0ZWQgTW92ZWQgdG8gYFN0b3JhZ2VNYXBgIHNlcnZpY2UuIFdpbGwgYmUgcmVtb3ZlZCBpbiB2OS5cbiAgICogTm90ZSB0aGF0IHdoaWxlIHRoaXMgbWV0aG9kIHdhcyBnaXZpbmcgeW91IGFsbCBrZXlzIGF0IG9uY2UgaW4gYW4gYXJyYXksXG4gICAqIHRoZSBuZXcgYGtleXMoKWAgbWV0aG9kIGluIGBTdG9yYWdlTWFwYCBzZXJ2aWNlIHdpbGwgKml0ZXJhdGUqIG9uIGVhY2gga2V5LlxuICAgKi9cbiAga2V5cygpOiBPYnNlcnZhYmxlPHN0cmluZ1tdPiB7XG5cbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlTWFwLmtleXMoKS5waXBlKFxuICAgICAgLyogQmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIHY3OiB0cmFuc2Zvcm0gaXRlcmF0aW5nIGBPYnNlcnZhYmxlYCB0byBhIHNpbmdsZSBhcnJheSB2YWx1ZSAqL1xuICAgICAgdG9BcnJheSgpLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBUZWxscyBpZiBhIGtleSBleGlzdHMgaW4gc3RvcmFnZVxuICAgKiBAcmV0dXJucyBBIFJ4SlMgYE9ic2VydmFibGVgIHRlbGxpbmcgaWYgdGhlIGtleSBleGlzdHNcbiAgICogQGRlcHJlY2F0ZWQgTW92ZWQgdG8gYFN0b3JhZ2VNYXBgIHNlcnZpY2UuIFdpbGwgYmUgcmVtb3ZlZCBpbiB2OS5cbiAgICovXG4gIGhhcyhrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuXG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZU1hcC5oYXMoa2V5KTtcblxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhbiBpdGVtIGluIHN0b3JhZ2UsIGFuZCBhdXRvLXN1YnNjcmliZVxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEBwYXJhbSBkYXRhIFRoZSBpdGVtJ3MgdmFsdWVcbiAgICogKipXQVJOSU5HOiBzaG91bGQgYmUgYXZvaWRlZCBpbiBtb3N0IGNhc2VzLCB1c2UgdGhpcyBtZXRob2Qgb25seSBpZiB0aGVzZSBjb25kaXRpb25zIGFyZSBmdWxmaWxsZWQ6KipcbiAgICogLSB5b3UgZG9uJ3QgbmVlZCB0byBtYW5hZ2UgdGhlIGVycm9yIGNhbGxiYWNrIChlcnJvcnMgd2lsbCBzaWxlbnRseSBmYWlsKSxcbiAgICogLSB5b3UgZG9uJ3QgbmVlZCB0byB3YWl0IHRoZSBvcGVyYXRpb24gdG8gZmluaXNoIGJlZm9yZSB0aGUgbmV4dCBvbmUgKHJlbWVtYmVyLCBpdCdzIGFzeW5jaHJvbm91cykuXG4gICAqIEBkZXByZWNhdGVkIFByb21vdGVkIGJhZCBwcmFjdGljZXMuIFdpbGwgYmUgcmVtb3ZlZCBpbiB2OS5cbiAgICovXG4gIHNldEl0ZW1TdWJzY3JpYmUoa2V5OiBzdHJpbmcsIGRhdGE6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBvYmplY3QpOiB2b2lkIHtcblxuICAgIHRoaXMuc2V0SXRlbShrZXksIGRhdGEpLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiAoKSA9PiB7fSxcbiAgICAgIGVycm9yOiAoKSA9PiB7fSxcbiAgICB9KTtcblxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhbiBpdGVtIGluIHN0b3JhZ2UsIGFuZCBhdXRvLXN1YnNjcmliZVxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqICoqV0FSTklORzogc2hvdWxkIGJlIGF2b2lkZWQgaW4gbW9zdCBjYXNlcywgdXNlIHRoaXMgbWV0aG9kIG9ubHkgaWYgdGhlc2UgY29uZGl0aW9ucyBhcmUgZnVsZmlsbGVkOioqXG4gICAqIC0geW91IGRvbid0IG5lZWQgdG8gbWFuYWdlIHRoZSBlcnJvciBjYWxsYmFjayAoZXJyb3JzIHdpbGwgc2lsZW50bHkgZmFpbCksXG4gICAqIC0geW91IGRvbid0IG5lZWQgdG8gd2FpdCB0aGUgb3BlcmF0aW9uIHRvIGZpbmlzaCBiZWZvcmUgdGhlIG5leHQgb25lIChyZW1lbWJlciwgaXQncyBhc3luY2hyb25vdXMpLlxuICAgKiBAZGVwcmVjYXRlZCBQcm9tb3RlZCBiYWQgcHJhY3RpY2VzLiBXaWxsIGJlIHJlbW92ZWQgaW4gdjkuXG4gICAqL1xuICAgcmVtb3ZlSXRlbVN1YnNjcmliZShrZXk6IHN0cmluZyk6IHZvaWQge1xuXG4gICAgdGhpcy5yZW1vdmVJdGVtKGtleSkuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6ICgpID0+IHt9LFxuICAgICAgZXJyb3I6ICgpID0+IHt9LFxuICAgIH0pO1xuXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGFsbCBpdGVtcyBpbiBzdG9yYWdlLCBhbmQgYXV0by1zdWJzY3JpYmVcbiAgICogKipXQVJOSU5HOiBzaG91bGQgYmUgYXZvaWRlZCBpbiBtb3N0IGNhc2VzLCB1c2UgdGhpcyBtZXRob2Qgb25seSBpZiB0aGVzZSBjb25kaXRpb25zIGFyZSBmdWxmaWxsZWQ6KipcbiAgICogLSB5b3UgZG9uJ3QgbmVlZCB0byBtYW5hZ2UgdGhlIGVycm9yIGNhbGxiYWNrIChlcnJvcnMgd2lsbCBzaWxlbnRseSBmYWlsKSxcbiAgICogLSB5b3UgZG9uJ3QgbmVlZCB0byB3YWl0IHRoZSBvcGVyYXRpb24gdG8gZmluaXNoIGJlZm9yZSB0aGUgbmV4dCBvbmUgKHJlbWVtYmVyLCBpdCdzIGFzeW5jaHJvbm91cykuXG4gICAqIEBkZXByZWNhdGVkIFByb21vdGVkIGJhZCBwcmFjdGljZXMuIFdpbGwgYmUgcmVtb3ZlZCBpbiB2OS5cbiAgICovXG4gIGNsZWFyU3Vic2NyaWJlKCk6IHZvaWQge1xuXG4gICAgdGhpcy5jbGVhcigpLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiAoKSA9PiB7fSxcbiAgICAgIGVycm9yOiAoKSA9PiB7fSxcbiAgICB9KTtcblxuICB9XG5cbn1cbiJdfQ==