import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { mapTo, toArray, map } from 'rxjs/operators';
import { StorageMap } from './storage-map.service';
import * as i0 from "@angular/core";
import * as i1 from "./storage-map.service";
let LocalStorage = class LocalStorage {
    /* Use the `StorageMap` service to avoid code duplication */
    constructor(storageMap) {
        this.storageMap = storageMap;
    }
    /**
     * Number of items in storage
     * @deprecated Use `.length`, or use `.size` via the new `StorageMap` service. Will be removed in v9.
     */
    get size() {
        return this.length;
    }
    /**
     * Number of items in storage wrapped in an `Observable`
     *
     * @example
     * this.localStorage.length.subscribe((length) => {
     *   console.log(length);
     * });
     */
    get length() {
        return this.storageMap.size;
    }
    getItem(key, schema) {
        if (schema) {
            /* Backward compatibility with version <= 7 */
            const schemaFinal = ('schema' in schema) ? schema.schema : schema;
            return this.storageMap.get(key, schemaFinal).pipe(
            /* Transform `undefined` into `null` to align with `localStorage` API */
            map((value) => (value !== undefined) ? value : null));
        }
        else {
            return this.storageMap.get(key).pipe(
            /* Transform `undefined` into `null` to align with `localStorage` API */
            map((value) => (value !== undefined) ? value : null));
        }
    }
    /**
     * Set an item in storage.
     * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.
     * @param key The item's key
     * @param data The item's value
     * @param schema Optional JSON schema to validate the data
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.localStorage.set('key', 'value').subscribe(() => {});
     */
    setItem(key, data, schema) {
        return this.storageMap.set(key, data, schema).pipe(
        /* Transform `undefined` into `true` for backward compatibility with v7 */
        mapTo(true));
    }
    /**
     * Delete an item in storage
     * @param key The item's key
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.localStorage.delete('key').subscribe(() => {});
     */
    removeItem(key) {
        return this.storageMap.delete(key).pipe(
        /* Transform `undefined` into `true` for backward compatibility with v7 */
        mapTo(true));
    }
    /**
     * Delete all items in storage
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.localStorage.clear().subscribe(() => {});
     */
    clear() {
        return this.storageMap.clear().pipe(
        /* Transform `undefined` into `true` for backward compatibility with v7 */
        mapTo(true));
    }
    /**
     * Get all keys stored in storage
     * @returns A list of the keys wrapped in a RxJS `Observable`
     * @deprecated Moved to `StorageMap` service. Will be removed in v9.
     * Note that while this method was giving you all keys at once in an array,
     * the new `keys()` method in `StorageMap` service will *iterate* on each key.
     */
    keys() {
        return this.storageMap.keys().pipe(
        /* Backward compatibility with v7: transform iterating `Observable` to a single array value */
        toArray());
    }
    /**
     * Tells if a key exists in storage
     * @returns A RxJS `Observable` telling if the key exists
     * @deprecated Moved to `StorageMap` service. Will be removed in v9.
     */
    has(key) {
        return this.storageMap.has(key);
    }
    /**
     * Set an item in storage, and auto-subscribe
     * @param key The item's key
     * @param data The item's value
     * **WARNING: should be avoided in most cases, use this method only if these conditions are fulfilled:**
     * - you don't need to manage the error callback (errors will silently fail),
     * - you don't need to wait the operation to finish before the next one (remember, it's asynchronous).
     * @deprecated Promoted bad practices. Will be removed in v9.
     */
    setItemSubscribe(key, data) {
        this.setItem(key, data).subscribe({
            next: () => { },
            error: () => { },
        });
    }
    /**
     * Delete an item in storage, and auto-subscribe
     * @param key The item's key
     * **WARNING: should be avoided in most cases, use this method only if these conditions are fulfilled:**
     * - you don't need to manage the error callback (errors will silently fail),
     * - you don't need to wait the operation to finish before the next one (remember, it's asynchronous).
     * @deprecated Promoted bad practices. Will be removed in v9.
     */
    removeItemSubscribe(key) {
        this.removeItem(key).subscribe({
            next: () => { },
            error: () => { },
        });
    }
    /**
     * Delete all items in storage, and auto-subscribe
     * **WARNING: should be avoided in most cases, use this method only if these conditions are fulfilled:**
     * - you don't need to manage the error callback (errors will silently fail),
     * - you don't need to wait the operation to finish before the next one (remember, it's asynchronous).
     * @deprecated Promoted bad practices. Will be removed in v9.
     */
    clearSubscribe() {
        this.clear().subscribe({
            next: () => { },
            error: () => { },
        });
    }
};
LocalStorage.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function LocalStorage_Factory() { return new LocalStorage(i0.ɵɵinject(i1.StorageMap)); }, token: LocalStorage, providedIn: "root" });
LocalStorage = tslib_1.__decorate([
    Injectable({
        providedIn: 'root'
    }),
    tslib_1.__metadata("design:paramtypes", [StorageMap])
], LocalStorage);
export { LocalStorage };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9jYWwtc3RvcmFnZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neC1wd2EvbG9jYWwtc3RvcmFnZS8iLCJzb3VyY2VzIjpbImxpYi9zdG9yYWdlcy9sb2NhbC1zdG9yYWdlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFM0MsT0FBTyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFckQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHVCQUF1QixDQUFDOzs7QUFvQm5ELElBQWEsWUFBWSxHQUF6QixNQUFhLFlBQVk7SUEwQnZCLDREQUE0RDtJQUM1RCxZQUFzQixVQUFzQjtRQUF0QixlQUFVLEdBQVYsVUFBVSxDQUFZO0lBQUcsQ0FBQztJQXpCaEQ7OztPQUdHO0lBQ0gsSUFBSSxJQUFJO1FBRU4sT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBRXJCLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsSUFBSSxNQUFNO1FBRVIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQztJQUU5QixDQUFDO0lBa0RELE9BQU8sQ0FBVSxHQUFXLEVBQUUsTUFBd0Q7UUFFcEYsSUFBSSxNQUFNLEVBQUU7WUFFViw4Q0FBOEM7WUFDOUMsTUFBTSxXQUFXLEdBQWUsQ0FBQyxRQUFRLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztZQUU5RSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFJLEdBQUcsRUFBRSxXQUFXLENBQUMsQ0FBQyxJQUFJO1lBQ2xELHdFQUF3RTtZQUN4RSxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUMsS0FBSyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUNyRCxDQUFDO1NBRUg7YUFBTTtZQUVMLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSTtZQUNsQyx3RUFBd0U7WUFDeEUsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQUssS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FDckQsQ0FBQztTQUVIO0lBRUgsQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSCxPQUFPLENBQUMsR0FBVyxFQUFFLElBQVMsRUFBRSxNQUFtQjtRQUVqRCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUMsSUFBSTtRQUNoRCwwRUFBMEU7UUFDMUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUNaLENBQUM7SUFFSixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILFVBQVUsQ0FBQyxHQUFXO1FBRXBCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSTtRQUNyQywwRUFBMEU7UUFDMUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUNaLENBQUM7SUFFSixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsS0FBSztRQUVILE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxJQUFJO1FBQ2pDLDBFQUEwRTtRQUMxRSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQ1osQ0FBQztJQUVKLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxJQUFJO1FBRUYsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxDQUFDLElBQUk7UUFDaEMsOEZBQThGO1FBQzlGLE9BQU8sRUFBRSxDQUNWLENBQUM7SUFFSixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEdBQUcsQ0FBQyxHQUFXO1FBRWIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUVsQyxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSCxnQkFBZ0IsQ0FBQyxHQUFXLEVBQUUsSUFBd0M7UUFFcEUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDO1lBQ2hDLElBQUksRUFBRSxHQUFHLEVBQUUsR0FBRSxDQUFDO1lBQ2QsS0FBSyxFQUFFLEdBQUcsRUFBRSxHQUFFLENBQUM7U0FDaEIsQ0FBQyxDQUFDO0lBRUwsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDRixtQkFBbUIsQ0FBQyxHQUFXO1FBRTlCLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDO1lBQzdCLElBQUksRUFBRSxHQUFHLEVBQUUsR0FBRSxDQUFDO1lBQ2QsS0FBSyxFQUFFLEdBQUcsRUFBRSxHQUFFLENBQUM7U0FDaEIsQ0FBQyxDQUFDO0lBRUwsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILGNBQWM7UUFFWixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsU0FBUyxDQUFDO1lBQ3JCLElBQUksRUFBRSxHQUFHLEVBQUUsR0FBRSxDQUFDO1lBQ2QsS0FBSyxFQUFFLEdBQUcsRUFBRSxHQUFFLENBQUM7U0FDaEIsQ0FBQyxDQUFDO0lBRUwsQ0FBQztDQUVGLENBQUE7O0FBcE9ZLFlBQVk7SUFIeEIsVUFBVSxDQUFDO1FBQ1YsVUFBVSxFQUFFLE1BQU07S0FDbkIsQ0FBQzs2Q0E0QmtDLFVBQVU7R0EzQmpDLFlBQVksQ0FvT3hCO1NBcE9ZLFlBQVkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXBUbywgdG9BcnJheSwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBTdG9yYWdlTWFwIH0gZnJvbSAnLi9zdG9yYWdlLW1hcC5zZXJ2aWNlJztcbmltcG9ydCB7IEpTT05TY2hlbWEsIEpTT05TY2hlbWFCb29sZWFuLCBKU09OU2NoZW1hSW50ZWdlciwgSlNPTlNjaGVtYU51bWJlciwgSlNPTlNjaGVtYVN0cmluZywgSlNPTlNjaGVtYUFycmF5T2YgfSBmcm9tICcuLi92YWxpZGF0aW9uJztcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gdjlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMU0dldEl0ZW1PcHRpb25zIHtcblxuICAvKipcbiAgICogU3Vic2V0IG9mIHRoZSBKU09OIFNjaGVtYSBzdGFuZGFyZC5cbiAgICogVHlwZXMgYXJlIGVuZm9yY2VkIHRvIHZhbGlkYXRlIGV2ZXJ5dGhpbmc6IGVhY2ggdmFsdWUgKiptdXN0KiogaGF2ZSBhIGB0eXBlYC5cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9ibG9iL21hc3Rlci9kb2NzL1ZBTElEQVRJT04ubWR9XG4gICAqL1xuICBzY2hlbWE/OiBKU09OU2NoZW1hIHwgbnVsbDtcblxufVxuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBMb2NhbFN0b3JhZ2Uge1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgaXRlbXMgaW4gc3RvcmFnZVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYC5sZW5ndGhgLCBvciB1c2UgYC5zaXplYCB2aWEgdGhlIG5ldyBgU3RvcmFnZU1hcGAgc2VydmljZS4gV2lsbCBiZSByZW1vdmVkIGluIHY5LlxuICAgKi9cbiAgZ2V0IHNpemUoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcblxuICAgIHJldHVybiB0aGlzLmxlbmd0aDtcblxuICB9XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBpdGVtcyBpbiBzdG9yYWdlIHdyYXBwZWQgaW4gYW4gYE9ic2VydmFibGVgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMubG9jYWxTdG9yYWdlLmxlbmd0aC5zdWJzY3JpYmUoKGxlbmd0aCkgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKGxlbmd0aCk7XG4gICAqIH0pO1xuICAgKi9cbiAgZ2V0IGxlbmd0aCgpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuXG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZU1hcC5zaXplO1xuXG4gIH1cblxuICAvKiBVc2UgdGhlIGBTdG9yYWdlTWFwYCBzZXJ2aWNlIHRvIGF2b2lkIGNvZGUgZHVwbGljYXRpb24gKi9cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHN0b3JhZ2VNYXA6IFN0b3JhZ2VNYXApIHt9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpdGVtIHZhbHVlIGluIHN0b3JhZ2UuXG4gICAqIFRoZSBzaWduYXR1cmUgaGFzIG1hbnkgb3ZlcmxvYWRzIGR1ZSB0byB2YWxpZGF0aW9uLCAqKnBsZWFzZSByZWZlciB0byB0aGUgZG9jdW1lbnRhdGlvbi4qKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2Jsb2IvbWFzdGVyL2RvY3MvVkFMSURBVElPTi5tZH1cbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgKiBAcGFyYW0gc2NoZW1hIE9wdGlvbmFsIEpTT04gc2NoZW1hIHRvIHZhbGlkYXRlIHRoZSBkYXRhLlxuICAgKiAqKk5vdGUgeW91IG11c3QgcGFzcyB0aGUgc2NoZW1hIGRpcmVjdGx5IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuKipcbiAgICogKipQYXNzaW5nIHRoZSBzY2hlbWEgaW4gYW4gb2JqZWN0IGB7IHNjaGVtYSB9YCBpcyBkZXByZWNhdGVkIGFuZCBvbmx5IGhlcmUqKlxuICAgKiAqKmZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBpdCB3aWxsIGJlIHJlbW92ZWQgaW4gdjkuKipcbiAgICogQHJldHVybnMgVGhlIGl0ZW0ncyB2YWx1ZSBpZiB0aGUga2V5IGV4aXN0cywgYG51bGxgIG90aGVyd2lzZSwgd3JhcHBlZCBpbiBhIFJ4SlMgYE9ic2VydmFibGVgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMubG9jYWxTdG9yYWdlLmdldCgna2V5JywgeyB0eXBlOiAnc3RyaW5nJyB9KS5zdWJzY3JpYmUoKHJlc3VsdCkgPT4ge1xuICAgKiAgIHJlc3VsdDsgLy8gc3RyaW5nIG9yIG51bGxcbiAgICogfSk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGludGVyZmFjZSBVc2VyIHtcbiAgICogICBmaXJzdE5hbWU6IHN0cmluZztcbiAgICogICBsYXN0TmFtZT86IHN0cmluZztcbiAgICogfVxuICAgKlxuICAgKiBjb25zdCBzY2hlbWEgPSB7XG4gICAqICAgdHlwZTogJ29iamVjdCcsXG4gICAqICAgcHJvcGVydGllczoge1xuICAgKiAgICAgZmlyc3ROYW1lOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAqICAgICBsYXN0TmFtZTogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgKiAgIH0sXG4gICAqICAgcmVxdWlyZWQ6IFsnZmlyc3ROYW1lJ11cbiAgICogfTtcbiAgICpcbiAgICogdGhpcy5sb2NhbFN0b3JhZ2UuZ2V0PFVzZXI+KCd1c2VyJywgc2NoZW1hKS5zdWJzY3JpYmUoKHVzZXIpID0+IHtcbiAgICogICBpZiAodXNlcikge1xuICAgKiAgICAgdXNlci5maXJzdE5hbWU7XG4gICAqICAgfVxuICAgKiB9KTtcbiAgICovXG4gIGdldEl0ZW08VCA9IHN0cmluZz4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYVN0cmluZyk6IE9ic2VydmFibGU8c3RyaW5nIHwgbnVsbD47XG4gIGdldEl0ZW08VCA9IG51bWJlcj4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUludGVnZXLCoHwgSlNPTlNjaGVtYU51bWJlcik6IE9ic2VydmFibGU8bnVtYmVyIHwgbnVsbD47XG4gIGdldEl0ZW08VCA9IGJvb2xlYW4+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFCb29sZWFuKTogT2JzZXJ2YWJsZTxib29sZWFuIHwgbnVsbD47XG4gIGdldEl0ZW08VCA9IHN0cmluZ1tdPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQXJyYXlPZjxKU09OU2NoZW1hU3RyaW5nPik6IE9ic2VydmFibGU8c3RyaW5nW10gfCBudWxsPjtcbiAgZ2V0SXRlbTxUID0gbnVtYmVyW10+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFBcnJheU9mPEpTT05TY2hlbWFJbnRlZ2VywqB8IEpTT05TY2hlbWFOdW1iZXI+KTogT2JzZXJ2YWJsZTxudW1iZXJbXSB8IG51bGw+O1xuICBnZXRJdGVtPFQgPSBib29sZWFuW10+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFBcnJheU9mPEpTT05TY2hlbWFCb29sZWFuPik6IE9ic2VydmFibGU8Ym9vbGVhbltdIHwgbnVsbD47XG4gIGdldEl0ZW08VCA9IGFueT4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYSB8IHsgc2NoZW1hOiBKU09OU2NoZW1hIH0pOiBPYnNlcnZhYmxlPFQgfCBudWxsPjtcbiAgZ2V0SXRlbTxUID0gdW5rbm93bj4oa2V5OiBzdHJpbmcsIHNjaGVtYT86IEpTT05TY2hlbWEpOiBPYnNlcnZhYmxlPHVua25vd24+O1xuICBnZXRJdGVtPFQgPSBhbnk+KGtleTogc3RyaW5nLCBzY2hlbWE/OiBKU09OU2NoZW1hIHwgeyBzY2hlbWE6IEpTT05TY2hlbWEgfSB8IHVuZGVmaW5lZCkge1xuXG4gICAgaWYgKHNjaGVtYSkge1xuXG4gICAgICAvKiBCYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggdmVyc2lvbiA8PSA3ICovXG4gICAgICBjb25zdCBzY2hlbWFGaW5hbDogSlNPTlNjaGVtYSA9ICgnc2NoZW1hJyBpbiBzY2hlbWEpID8gc2NoZW1hLnNjaGVtYSA6IHNjaGVtYTtcblxuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZU1hcC5nZXQ8VD4oa2V5LCBzY2hlbWFGaW5hbCkucGlwZShcbiAgICAgICAgLyogVHJhbnNmb3JtIGB1bmRlZmluZWRgIGludG8gYG51bGxgIHRvIGFsaWduIHdpdGggYGxvY2FsU3RvcmFnZWAgQVBJICovXG4gICAgICAgIG1hcCgodmFsdWUpID0+ICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSA/IHZhbHVlIDogbnVsbCksXG4gICAgICApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZU1hcC5nZXQoa2V5KS5waXBlKFxuICAgICAgICAvKiBUcmFuc2Zvcm0gYHVuZGVmaW5lZGAgaW50byBgbnVsbGAgdG8gYWxpZ24gd2l0aCBgbG9jYWxTdG9yYWdlYCBBUEkgKi9cbiAgICAgICAgbWFwKCh2YWx1ZSkgPT4gKHZhbHVlICE9PSB1bmRlZmluZWQpID8gdmFsdWUgOiBudWxsKSxcbiAgICAgICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYW4gaXRlbSBpbiBzdG9yYWdlLlxuICAgKiBOb3RlIHRoYXQgc2V0dGluZyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgd2lsbCByZW1vdmUgdGhlIGl0ZW0gdG8gYXZvaWQgc29tZSBicm93c2VycyBpc3N1ZXMuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHBhcmFtIGRhdGEgVGhlIGl0ZW0ncyB2YWx1ZVxuICAgKiBAcGFyYW0gc2NoZW1hIE9wdGlvbmFsIEpTT04gc2NoZW1hIHRvIHZhbGlkYXRlIHRoZSBkYXRhXG4gICAqIEByZXR1cm5zIEEgUnhKUyBgT2JzZXJ2YWJsZWAgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5sb2NhbFN0b3JhZ2Uuc2V0KCdrZXknLCAndmFsdWUnKS5zdWJzY3JpYmUoKCkgPT4ge30pO1xuICAgKi9cbiAgc2V0SXRlbShrZXk6IHN0cmluZywgZGF0YTogYW55LCBzY2hlbWE/OiBKU09OU2NoZW1hKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG5cbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlTWFwLnNldChrZXksIGRhdGEsIHNjaGVtYSkucGlwZShcbiAgICAgIC8qIFRyYW5zZm9ybSBgdW5kZWZpbmVkYCBpbnRvIGB0cnVlYCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIHY3ICovXG4gICAgICBtYXBUbyh0cnVlKSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGFuIGl0ZW0gaW4gc3RvcmFnZVxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEByZXR1cm5zIEEgUnhKUyBgT2JzZXJ2YWJsZWAgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5sb2NhbFN0b3JhZ2UuZGVsZXRlKCdrZXknKS5zdWJzY3JpYmUoKCkgPT4ge30pO1xuICAgKi9cbiAgcmVtb3ZlSXRlbShrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuXG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZU1hcC5kZWxldGUoa2V5KS5waXBlKFxuICAgICAgLyogVHJhbnNmb3JtIGB1bmRlZmluZWRgIGludG8gYHRydWVgIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggdjcgKi9cbiAgICAgIG1hcFRvKHRydWUpLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYWxsIGl0ZW1zIGluIHN0b3JhZ2VcbiAgICogQHJldHVybnMgQSBSeEpTIGBPYnNlcnZhYmxlYCB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLmxvY2FsU3RvcmFnZS5jbGVhcigpLnN1YnNjcmliZSgoKSA9PiB7fSk7XG4gICAqL1xuICBjbGVhcigpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcblxuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VNYXAuY2xlYXIoKS5waXBlKFxuICAgICAgLyogVHJhbnNmb3JtIGB1bmRlZmluZWRgIGludG8gYHRydWVgIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggdjcgKi9cbiAgICAgIG1hcFRvKHRydWUpLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGtleXMgc3RvcmVkIGluIHN0b3JhZ2VcbiAgICogQHJldHVybnMgQSBsaXN0IG9mIHRoZSBrZXlzIHdyYXBwZWQgaW4gYSBSeEpTIGBPYnNlcnZhYmxlYFxuICAgKiBAZGVwcmVjYXRlZCBNb3ZlZCB0byBgU3RvcmFnZU1hcGAgc2VydmljZS4gV2lsbCBiZSByZW1vdmVkIGluIHY5LlxuICAgKiBOb3RlIHRoYXQgd2hpbGUgdGhpcyBtZXRob2Qgd2FzIGdpdmluZyB5b3UgYWxsIGtleXMgYXQgb25jZSBpbiBhbiBhcnJheSxcbiAgICogdGhlIG5ldyBga2V5cygpYCBtZXRob2QgaW4gYFN0b3JhZ2VNYXBgIHNlcnZpY2Ugd2lsbCAqaXRlcmF0ZSogb24gZWFjaCBrZXkuXG4gICAqL1xuICBrZXlzKCk6IE9ic2VydmFibGU8c3RyaW5nW10+IHtcblxuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VNYXAua2V5cygpLnBpcGUoXG4gICAgICAvKiBCYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggdjc6IHRyYW5zZm9ybSBpdGVyYXRpbmcgYE9ic2VydmFibGVgIHRvIGEgc2luZ2xlIGFycmF5IHZhbHVlICovXG4gICAgICB0b0FycmF5KCksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIFRlbGxzIGlmIGEga2V5IGV4aXN0cyBpbiBzdG9yYWdlXG4gICAqIEByZXR1cm5zIEEgUnhKUyBgT2JzZXJ2YWJsZWAgdGVsbGluZyBpZiB0aGUga2V5IGV4aXN0c1xuICAgKiBAZGVwcmVjYXRlZCBNb3ZlZCB0byBgU3RvcmFnZU1hcGAgc2VydmljZS4gV2lsbCBiZSByZW1vdmVkIGluIHY5LlxuICAgKi9cbiAgaGFzKGtleTogc3RyaW5nKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG5cbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlTWFwLmhhcyhrZXkpO1xuXG4gIH1cblxuICAvKipcbiAgICogU2V0IGFuIGl0ZW0gaW4gc3RvcmFnZSwgYW5kIGF1dG8tc3Vic2NyaWJlXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHBhcmFtIGRhdGEgVGhlIGl0ZW0ncyB2YWx1ZVxuICAgKiAqKldBUk5JTkc6IHNob3VsZCBiZSBhdm9pZGVkIGluIG1vc3QgY2FzZXMsIHVzZSB0aGlzIG1ldGhvZCBvbmx5IGlmIHRoZXNlIGNvbmRpdGlvbnMgYXJlIGZ1bGZpbGxlZDoqKlxuICAgKiAtIHlvdSBkb24ndCBuZWVkIHRvIG1hbmFnZSB0aGUgZXJyb3IgY2FsbGJhY2sgKGVycm9ycyB3aWxsIHNpbGVudGx5IGZhaWwpLFxuICAgKiAtIHlvdSBkb24ndCBuZWVkIHRvIHdhaXQgdGhlIG9wZXJhdGlvbiB0byBmaW5pc2ggYmVmb3JlIHRoZSBuZXh0IG9uZSAocmVtZW1iZXIsIGl0J3MgYXN5bmNocm9ub3VzKS5cbiAgICogQGRlcHJlY2F0ZWQgUHJvbW90ZWQgYmFkIHByYWN0aWNlcy4gV2lsbCBiZSByZW1vdmVkIGluIHY5LlxuICAgKi9cbiAgc2V0SXRlbVN1YnNjcmliZShrZXk6IHN0cmluZywgZGF0YTogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG9iamVjdCk6IHZvaWQge1xuXG4gICAgdGhpcy5zZXRJdGVtKGtleSwgZGF0YSkuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6ICgpID0+IHt9LFxuICAgICAgZXJyb3I6ICgpID0+IHt9LFxuICAgIH0pO1xuXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGFuIGl0ZW0gaW4gc3RvcmFnZSwgYW5kIGF1dG8tc3Vic2NyaWJlXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogKipXQVJOSU5HOiBzaG91bGQgYmUgYXZvaWRlZCBpbiBtb3N0IGNhc2VzLCB1c2UgdGhpcyBtZXRob2Qgb25seSBpZiB0aGVzZSBjb25kaXRpb25zIGFyZSBmdWxmaWxsZWQ6KipcbiAgICogLSB5b3UgZG9uJ3QgbmVlZCB0byBtYW5hZ2UgdGhlIGVycm9yIGNhbGxiYWNrIChlcnJvcnMgd2lsbCBzaWxlbnRseSBmYWlsKSxcbiAgICogLSB5b3UgZG9uJ3QgbmVlZCB0byB3YWl0IHRoZSBvcGVyYXRpb24gdG8gZmluaXNoIGJlZm9yZSB0aGUgbmV4dCBvbmUgKHJlbWVtYmVyLCBpdCdzIGFzeW5jaHJvbm91cykuXG4gICAqIEBkZXByZWNhdGVkIFByb21vdGVkIGJhZCBwcmFjdGljZXMuIFdpbGwgYmUgcmVtb3ZlZCBpbiB2OS5cbiAgICovXG4gICByZW1vdmVJdGVtU3Vic2NyaWJlKGtleTogc3RyaW5nKTogdm9pZCB7XG5cbiAgICB0aGlzLnJlbW92ZUl0ZW0oa2V5KS5zdWJzY3JpYmUoe1xuICAgICAgbmV4dDogKCkgPT4ge30sXG4gICAgICBlcnJvcjogKCkgPT4ge30sXG4gICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYWxsIGl0ZW1zIGluIHN0b3JhZ2UsIGFuZCBhdXRvLXN1YnNjcmliZVxuICAgKiAqKldBUk5JTkc6IHNob3VsZCBiZSBhdm9pZGVkIGluIG1vc3QgY2FzZXMsIHVzZSB0aGlzIG1ldGhvZCBvbmx5IGlmIHRoZXNlIGNvbmRpdGlvbnMgYXJlIGZ1bGZpbGxlZDoqKlxuICAgKiAtIHlvdSBkb24ndCBuZWVkIHRvIG1hbmFnZSB0aGUgZXJyb3IgY2FsbGJhY2sgKGVycm9ycyB3aWxsIHNpbGVudGx5IGZhaWwpLFxuICAgKiAtIHlvdSBkb24ndCBuZWVkIHRvIHdhaXQgdGhlIG9wZXJhdGlvbiB0byBmaW5pc2ggYmVmb3JlIHRoZSBuZXh0IG9uZSAocmVtZW1iZXIsIGl0J3MgYXN5bmNocm9ub3VzKS5cbiAgICogQGRlcHJlY2F0ZWQgUHJvbW90ZWQgYmFkIHByYWN0aWNlcy4gV2lsbCBiZSByZW1vdmVkIGluIHY5LlxuICAgKi9cbiAgY2xlYXJTdWJzY3JpYmUoKTogdm9pZCB7XG5cbiAgICB0aGlzLmNsZWFyKCkuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6ICgpID0+IHt9LFxuICAgICAgZXJyb3I6ICgpID0+IHt9LFxuICAgIH0pO1xuXG4gIH1cblxufVxuIl19