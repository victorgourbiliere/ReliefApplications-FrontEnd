import * as tslib_1 from "tslib";
import { Injectable, Inject } from '@angular/core';
import { throwError, of } from 'rxjs';
import { mergeMap, catchError } from 'rxjs/operators';
import { ValidationError } from './exceptions';
import { JSONValidator } from '../validation';
import { LocalDatabase, IDB_BROKEN_ERROR, LocalStorageDatabase, IndexedDBDatabase, MemoryDatabase } from '../databases';
import { LS_PREFIX, LOCAL_STORAGE_PREFIX } from '../tokens';
import * as i0 from "@angular/core";
import * as i1 from "../databases/local-database";
import * as i2 from "../validation/json-validator";
import * as i3 from "../tokens";
let StorageMap = class StorageMap {
    /**
     * Constructor params are provided by Angular (but can also be passed manually in tests)
     * @param database Storage to use
     * @param jsonValidator Validator service
     * @param LSPrefix Prefix for `localStorage` keys to avoid collision for multiple apps on the same subdomain or for interoperability
     * @param oldPrefix Prefix option prior to v8 to avoid collision for multiple apps on the same subdomain or for interoperability
     */
    constructor(database, jsonValidator = new JSONValidator(), LSPrefix = '', 
    // tslint:disable-next-line: deprecation
    oldPrefix = '') {
        this.database = database;
        this.jsonValidator = jsonValidator;
        this.LSPrefix = LSPrefix;
        this.oldPrefix = oldPrefix;
    }
    /**
     * **Number of items** in storage, wrapped in an `Observable`.
     *
     * @example
     * this.storageMap.size.subscribe((size) => {
     *   console.log(size);
     * });
     */
    get size() {
        return this.database.size;
    }
    /**
     * Tells you which storage engine is used. *Only useful for interoperability.*
     * Note that due to some browsers issues in some special contexts
     * (Firefox private mode and Safari cross-origin iframes),
     * **this information may be wrong at initialization,**
     * as the storage could fallback from `indexedDB` to `localStorage`
     * only after a first read or write operation.
     * @returns Storage engine used
     *
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/master/docs/INTEROPERABILITY.md}
     *
     * @example
     * if (this.storageMap.backingEngine === 'indexedDB') {}
     */
    get backingEngine() {
        if (this.database instanceof IndexedDBDatabase) {
            return 'indexedDB';
        }
        else if (this.database instanceof LocalStorageDatabase) {
            return 'localStorage';
        }
        else if (this.database instanceof MemoryDatabase) {
            return 'memory';
        }
        else {
            return 'unknown';
        }
    }
    /**
     * Info about `indexedDB` database. *Only useful for interoperability.*
     * @returns `indexedDB` database name, store name and database version.
     * **Values will be empty if the storage is not `indexedDB`,**
     * **so it should be used after an engine check**.
     *
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/master/docs/INTEROPERABILITY.md}
     *
     * @example
     * if (this.storageMap.backingEngine === 'indexedDB') {
     *   const { database, store, version } = this.storageMap.backingStore;
     * }
     */
    get backingStore() {
        return (this.database instanceof IndexedDBDatabase) ?
            this.database.backingStore :
            { database: '', store: '', version: 0 };
    }
    /**
     * Info about `localStorage` fallback storage. *Only useful for interoperability.*
     * @returns `localStorage` prefix.
     * **Values will be empty if the storage is not `localStorage`,**
     * **so it should be used after an engine check**.
     *
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/master/docs/INTEROPERABILITY.md}
     *
     * @example
     * if (this.storageMap.backingEngine === 'localStorage') {
     *   const { prefix } = this.storageMap.fallbackBackingStore;
     * }
     */
    get fallbackBackingStore() {
        return (this.database instanceof LocalStorageDatabase) ?
            { prefix: this.database.prefix } :
            { prefix: '' };
    }
    get(key, schema) {
        /* Get the data in storage */
        return this.database.get(key).pipe(
        /* Check if `indexedDb` is broken */
        this.catchIDBBroken(() => this.database.get(key)), mergeMap((data) => {
            /* No need to validate if the data is empty */
            if ((data === undefined) || (data === null)) {
                return of(undefined);
            }
            else if (schema) {
                /* Validate data against a JSON schema if provided */
                if (!this.jsonValidator.validate(data, schema)) {
                    return throwError(new ValidationError());
                }
                /* Data have been checked, so it's OK to cast */
                return of(data);
            }
            /* Cast to unknown as the data wasn't checked */
            return of(data);
        }));
    }
    /**
     * Set an item in storage.
     * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.
     * @param key The item's key
     * @param data The item's value
     * @param schema Optional JSON schema to validate the data
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.storageMap.set('key', 'value').subscribe(() => {});
     */
    set(key, data, schema) {
        /* Storing `undefined` or `null` is useless and can cause issues in `indexedDb` in some browsers,
         * so removing item instead for all storages to have a consistent API */
        if ((data === undefined) || (data === null)) {
            return this.delete(key);
        }
        /* Validate data against a JSON schema if provided */
        if (schema && !this.jsonValidator.validate(data, schema)) {
            return throwError(new ValidationError());
        }
        return this.database.set(key, data)
            /* Catch if `indexedDb` is broken */
            .pipe(this.catchIDBBroken(() => this.database.set(key, data)));
    }
    /**
     * Delete an item in storage
     * @param key The item's key
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.storageMap.delete('key').subscribe(() => {});
     */
    delete(key) {
        return this.database.delete(key)
            /* Catch if `indexedDb` is broken */
            .pipe(this.catchIDBBroken(() => this.database.delete(key)));
    }
    /**
     * Delete all items in storage
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.storageMap.clear().subscribe(() => {});
     */
    clear() {
        return this.database.clear()
            /* Catch if `indexedDb` is broken */
            .pipe(this.catchIDBBroken(() => this.database.clear()));
    }
    /**
     * Get all keys stored in storage. Note **this is an *iterating* `Observable`**:
     * * if there is no key, the `next` callback will not be invoked,
     * * if you need to wait the whole operation to end, be sure to act in the `complete` callback,
     * as this `Observable` can emit several values and so will invoke the `next` callback several times.
     * @returns A list of the keys wrapped in a RxJS `Observable`
     *
     * @example
     * this.storageMap.keys().subscribe({
     *   next: (key) => { console.log(key); },
     *   complete: () => { console.log('Done'); },
     * });
     */
    keys() {
        return this.database.keys()
            /* Catch if `indexedDb` is broken */
            .pipe(this.catchIDBBroken(() => this.database.keys()));
    }
    /**
     * Tells if a key exists in storage
     * @returns A RxJS `Observable` telling if the key exists
     *
     * @example
     * this.storageMap.has('key').subscribe((hasKey) => {
     *   if (hasKey) {}
     * });
     */
    has(key) {
        return this.database.has(key)
            /* Catch if `indexedDb` is broken */
            .pipe(this.catchIDBBroken(() => this.database.has(key)));
    }
    /**
     * RxJS operator to catch if `indexedDB` is broken
     * @param operationCallback Callback with the operation to redo
     */
    catchIDBBroken(operationCallback) {
        return catchError((error) => {
            /* Check if `indexedDB` is broken based on error message (the specific error class seems to be lost in the process) */
            if ((error !== undefined) && (error !== null) && (error.message === IDB_BROKEN_ERROR)) {
                /* When storage is fully disabled in browser (via the "Block all cookies" option),
                 * just trying to check `localStorage` variable causes a security exception.
                 * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118
                 */
                try {
                    if ('getItem' in localStorage) {
                        /* Fallback to `localStorage` if available */
                        this.database = new LocalStorageDatabase(this.LSPrefix, this.oldPrefix);
                    }
                    else {
                        /* Fallback to memory storage otherwise */
                        this.database = new MemoryDatabase();
                    }
                }
                catch (_a) {
                    /* Fallback to memory storage otherwise */
                    this.database = new MemoryDatabase();
                }
                /* Redo the operation */
                return operationCallback();
            }
            else {
                /* Otherwise, rethrow the error */
                return throwError(error);
            }
        });
    }
};
StorageMap.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function StorageMap_Factory() { return new StorageMap(i0.ɵɵinject(i1.LocalDatabase), i0.ɵɵinject(i2.JSONValidator), i0.ɵɵinject(i3.LS_PREFIX), i0.ɵɵinject(i3.LOCAL_STORAGE_PREFIX)); }, token: StorageMap, providedIn: "root" });
StorageMap = tslib_1.__decorate([
    Injectable({
        providedIn: 'root'
    }),
    tslib_1.__param(2, Inject(LS_PREFIX)),
    tslib_1.__param(3, Inject(LOCAL_STORAGE_PREFIX)),
    tslib_1.__metadata("design:paramtypes", [LocalDatabase,
        JSONValidator, Object, Object])
], StorageMap);
export { StorageMap };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmFnZS1tYXAuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3gtcHdhL2xvY2FsLXN0b3JhZ2UvIiwic291cmNlcyI6WyJsaWIvc3RvcmFnZXMvc3RvcmFnZS1tYXAuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkQsT0FBTyxFQUFjLFVBQVUsRUFBRSxFQUFFLEVBQW9CLE1BQU0sTUFBTSxDQUFDO0FBQ3BFLE9BQU8sRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFdEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUMvQyxPQUFPLEVBRWtELGFBQWEsRUFDckUsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGFBQWEsRUFBRSxnQkFBZ0IsRUFBRSxvQkFBb0IsRUFBRSxpQkFBaUIsRUFBRSxjQUFjLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDeEgsT0FBTyxFQUFFLFNBQVMsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLFdBQVcsQ0FBQzs7Ozs7QUFLNUQsSUFBYSxVQUFVLEdBQXZCLE1BQWEsVUFBVTtJQUVyQjs7Ozs7O09BTUc7SUFDSCxZQUNZLFFBQXVCLEVBQ3ZCLGdCQUErQixJQUFJLGFBQWEsRUFBRSxFQUMvQixXQUFXLEVBQUU7SUFDMUMsd0NBQXdDO0lBQ0EsWUFBWSxFQUFFO1FBSjVDLGFBQVEsR0FBUixRQUFRLENBQWU7UUFDdkIsa0JBQWEsR0FBYixhQUFhLENBQXFDO1FBQy9CLGFBQVEsR0FBUixRQUFRLENBQUs7UUFFRixjQUFTLEdBQVQsU0FBUyxDQUFLO0lBQ3JELENBQUM7SUFFSjs7Ozs7OztPQU9HO0lBQ0gsSUFBSSxJQUFJO1FBRU4sT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQztJQUU1QixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7T0FhRztJQUNILElBQUksYUFBYTtRQUVmLElBQUksSUFBSSxDQUFDLFFBQVEsWUFBWSxpQkFBaUIsRUFBRTtZQUU5QyxPQUFPLFdBQVcsQ0FBQztTQUVwQjthQUFNLElBQUksSUFBSSxDQUFDLFFBQVEsWUFBWSxvQkFBb0IsRUFBRTtZQUV4RCxPQUFPLGNBQWMsQ0FBQztTQUV2QjthQUFNLElBQUksSUFBSSxDQUFDLFFBQVEsWUFBWSxjQUFjLEVBQUU7WUFFbEQsT0FBTyxRQUFRLENBQUM7U0FFakI7YUFBTTtZQUVMLE9BQU8sU0FBUyxDQUFDO1NBRWxCO0lBRUgsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7T0FZRztJQUNILElBQUksWUFBWTtRQUVkLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxZQUFZLGlCQUFpQixDQUFDLENBQUMsQ0FBQztZQUNuRCxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQzVCLEVBQUUsUUFBUSxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsQ0FBQztJQUU1QyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7OztPQVlHO0lBQ0gsSUFBSSxvQkFBb0I7UUFFdEIsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLFlBQVksb0JBQW9CLENBQUMsQ0FBQyxDQUFDO1lBQ3RELEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztZQUNsQyxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsQ0FBQztJQUVuQixDQUFDO0lBNENELEdBQUcsQ0FBVSxHQUFXLEVBQUUsTUFBbUI7UUFFM0MsNkJBQTZCO1FBQzdCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUksR0FBRyxDQUFDLENBQUMsSUFBSTtRQUNuQyxvQ0FBb0M7UUFDcEMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBSSxHQUFHLENBQUMsQ0FBQyxFQUNwRCxRQUFRLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTtZQUVoQiw4Q0FBOEM7WUFDOUMsSUFBSSxDQUFDLElBQUksS0FBSyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsRUFBRTtnQkFFM0MsT0FBTyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUM7YUFFdEI7aUJBQU0sSUFBSSxNQUFNLEVBQUU7Z0JBRWpCLHFEQUFxRDtnQkFDckQsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsRUFBRTtvQkFDOUMsT0FBTyxVQUFVLENBQUMsSUFBSSxlQUFlLEVBQUUsQ0FBQyxDQUFDO2lCQUMxQztnQkFFRCxnREFBZ0Q7Z0JBQ2hELE9BQU8sRUFBRSxDQUFDLElBQXFCLENBQUMsQ0FBQzthQUVsQztZQUVELGdEQUFnRDtZQUNoRCxPQUFPLEVBQUUsQ0FBQyxJQUFlLENBQUMsQ0FBQztRQUU3QixDQUFDLENBQUMsQ0FDSCxDQUFDO0lBRUosQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSCxHQUFHLENBQUMsR0FBVyxFQUFFLElBQVMsRUFBRSxNQUFtQjtRQUU3QztnRkFDd0U7UUFDeEUsSUFBSSxDQUFDLElBQUksS0FBSyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsRUFBRTtZQUMzQyxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDekI7UUFFRCxxREFBcUQ7UUFDckQsSUFBSSxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLEVBQUU7WUFDeEQsT0FBTyxVQUFVLENBQUMsSUFBSSxlQUFlLEVBQUUsQ0FBQyxDQUFDO1NBQzFDO1FBRUQsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDO1lBQ2pDLG9DQUFvQzthQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRW5FLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsTUFBTSxDQUFDLEdBQVc7UUFFaEIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUM7WUFDOUIsb0NBQW9DO2FBQ25DLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVoRSxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsS0FBSztRQUVILE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUU7WUFDMUIsb0NBQW9DO2FBQ25DLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBRTVELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7O09BWUc7SUFDSCxJQUFJO1FBRUYsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRTtZQUN6QixvQ0FBb0M7YUFDbkMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFFM0QsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0gsR0FBRyxDQUFDLEdBQVc7UUFFYixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztZQUMzQixvQ0FBb0M7YUFDbkMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRTdELENBQUM7SUFFRDs7O09BR0c7SUFDTyxjQUFjLENBQUksaUJBQXNDO1FBRWhFLE9BQU8sVUFBVSxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUU7WUFFMUIsc0hBQXNIO1lBQ3RILElBQUksQ0FBQyxLQUFLLEtBQUssU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxLQUFLLGdCQUFnQixDQUFDLEVBQUU7Z0JBRXJGOzs7bUJBR0c7Z0JBQ0gsSUFBSTtvQkFFRixJQUFJLFNBQVMsSUFBSSxZQUFZLEVBQUU7d0JBRTdCLDZDQUE2Qzt3QkFDN0MsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLG9CQUFvQixDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO3FCQUV6RTt5QkFBTTt3QkFFTCwwQ0FBMEM7d0JBQzFDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxjQUFjLEVBQUUsQ0FBQztxQkFFdEM7aUJBRUY7Z0JBQUMsV0FBTTtvQkFFTiwwQ0FBMEM7b0JBQzFDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxjQUFjLEVBQUUsQ0FBQztpQkFFdEM7Z0JBRUQsd0JBQXdCO2dCQUN4QixPQUFPLGlCQUFpQixFQUFFLENBQUM7YUFFNUI7aUJBQU07Z0JBRUwsa0NBQWtDO2dCQUNsQyxPQUFPLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUUxQjtRQUVILENBQUMsQ0FBQyxDQUFDO0lBRUwsQ0FBQztDQUVGLENBQUE7O0FBN1VZLFVBQVU7SUFIdEIsVUFBVSxDQUFDO1FBQ1YsVUFBVSxFQUFFLE1BQU07S0FDbkIsQ0FBQztJQWFHLG1CQUFBLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQTtJQUVqQixtQkFBQSxNQUFNLENBQUMsb0JBQW9CLENBQUMsQ0FBQTs2Q0FKVCxhQUFhO1FBQ1IsYUFBYTtHQVg3QixVQUFVLENBNlV0QjtTQTdVWSxVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCB0aHJvd0Vycm9yLCBvZiwgT3BlcmF0b3JGdW5jdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWVyZ2VNYXAsIGNhdGNoRXJyb3IgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IFZhbGlkYXRpb25FcnJvciB9IGZyb20gJy4vZXhjZXB0aW9ucyc7XG5pbXBvcnQge1xuICBKU09OU2NoZW1hLCBKU09OU2NoZW1hQm9vbGVhbiwgSlNPTlNjaGVtYUludGVnZXIsXG4gIEpTT05TY2hlbWFOdW1iZXIsIEpTT05TY2hlbWFTdHJpbmcsIEpTT05TY2hlbWFBcnJheU9mLCBKU09OVmFsaWRhdG9yXG59IGZyb20gJy4uL3ZhbGlkYXRpb24nO1xuaW1wb3J0IHsgTG9jYWxEYXRhYmFzZSwgSURCX0JST0tFTl9FUlJPUiwgTG9jYWxTdG9yYWdlRGF0YWJhc2UsIEluZGV4ZWREQkRhdGFiYXNlLCBNZW1vcnlEYXRhYmFzZSB9IGZyb20gJy4uL2RhdGFiYXNlcyc7XG5pbXBvcnQgeyBMU19QUkVGSVgsIExPQ0FMX1NUT1JBR0VfUFJFRklYIH0gZnJvbSAnLi4vdG9rZW5zJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgU3RvcmFnZU1hcCB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIHBhcmFtcyBhcmUgcHJvdmlkZWQgYnkgQW5ndWxhciAoYnV0IGNhbiBhbHNvIGJlIHBhc3NlZCBtYW51YWxseSBpbiB0ZXN0cylcbiAgICogQHBhcmFtIGRhdGFiYXNlIFN0b3JhZ2UgdG8gdXNlXG4gICAqIEBwYXJhbSBqc29uVmFsaWRhdG9yIFZhbGlkYXRvciBzZXJ2aWNlXG4gICAqIEBwYXJhbSBMU1ByZWZpeCBQcmVmaXggZm9yIGBsb2NhbFN0b3JhZ2VgIGtleXMgdG8gYXZvaWQgY29sbGlzaW9uIGZvciBtdWx0aXBsZSBhcHBzIG9uIHRoZSBzYW1lIHN1YmRvbWFpbiBvciBmb3IgaW50ZXJvcGVyYWJpbGl0eVxuICAgKiBAcGFyYW0gb2xkUHJlZml4IFByZWZpeCBvcHRpb24gcHJpb3IgdG8gdjggdG8gYXZvaWQgY29sbGlzaW9uIGZvciBtdWx0aXBsZSBhcHBzIG9uIHRoZSBzYW1lIHN1YmRvbWFpbiBvciBmb3IgaW50ZXJvcGVyYWJpbGl0eVxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIGRhdGFiYXNlOiBMb2NhbERhdGFiYXNlLFxuICAgIHByb3RlY3RlZCBqc29uVmFsaWRhdG9yOiBKU09OVmFsaWRhdG9yID0gbmV3IEpTT05WYWxpZGF0b3IoKSxcbiAgICBASW5qZWN0KExTX1BSRUZJWCkgcHJvdGVjdGVkIExTUHJlZml4ID0gJycsXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBkZXByZWNhdGlvblxuICAgIEBJbmplY3QoTE9DQUxfU1RPUkFHRV9QUkVGSVgpIHByb3RlY3RlZCBvbGRQcmVmaXggPSAnJyxcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiAqKk51bWJlciBvZiBpdGVtcyoqIGluIHN0b3JhZ2UsIHdyYXBwZWQgaW4gYW4gYE9ic2VydmFibGVgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLnN0b3JhZ2VNYXAuc2l6ZS5zdWJzY3JpYmUoKHNpemUpID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhzaXplKTtcbiAgICogfSk7XG4gICAqL1xuICBnZXQgc2l6ZSgpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuXG4gICAgcmV0dXJuIHRoaXMuZGF0YWJhc2Uuc2l6ZTtcblxuICB9XG5cbiAgLyoqXG4gICAqIFRlbGxzIHlvdSB3aGljaCBzdG9yYWdlIGVuZ2luZSBpcyB1c2VkLiAqT25seSB1c2VmdWwgZm9yIGludGVyb3BlcmFiaWxpdHkuKlxuICAgKiBOb3RlIHRoYXQgZHVlIHRvIHNvbWUgYnJvd3NlcnMgaXNzdWVzIGluIHNvbWUgc3BlY2lhbCBjb250ZXh0c1xuICAgKiAoRmlyZWZveCBwcml2YXRlIG1vZGUgYW5kIFNhZmFyaSBjcm9zcy1vcmlnaW4gaWZyYW1lcyksXG4gICAqICoqdGhpcyBpbmZvcm1hdGlvbiBtYXkgYmUgd3JvbmcgYXQgaW5pdGlhbGl6YXRpb24sKipcbiAgICogYXMgdGhlIHN0b3JhZ2UgY291bGQgZmFsbGJhY2sgZnJvbSBgaW5kZXhlZERCYCB0byBgbG9jYWxTdG9yYWdlYFxuICAgKiBvbmx5IGFmdGVyIGEgZmlyc3QgcmVhZCBvciB3cml0ZSBvcGVyYXRpb24uXG4gICAqIEByZXR1cm5zIFN0b3JhZ2UgZW5naW5lIHVzZWRcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9ibG9iL21hc3Rlci9kb2NzL0lOVEVST1BFUkFCSUxJVFkubWR9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGlmICh0aGlzLnN0b3JhZ2VNYXAuYmFja2luZ0VuZ2luZSA9PT0gJ2luZGV4ZWREQicpIHt9XG4gICAqL1xuICBnZXQgYmFja2luZ0VuZ2luZSgpOiAnaW5kZXhlZERCJyB8ICdsb2NhbFN0b3JhZ2UnIHzCoCdtZW1vcnknIHwgJ3Vua25vd24nIHtcblxuICAgIGlmICh0aGlzLmRhdGFiYXNlIGluc3RhbmNlb2YgSW5kZXhlZERCRGF0YWJhc2UpIHtcblxuICAgICAgcmV0dXJuICdpbmRleGVkREInO1xuXG4gICAgfSBlbHNlIGlmICh0aGlzLmRhdGFiYXNlIGluc3RhbmNlb2YgTG9jYWxTdG9yYWdlRGF0YWJhc2UpIHtcblxuICAgICAgcmV0dXJuICdsb2NhbFN0b3JhZ2UnO1xuXG4gICAgfSBlbHNlIGlmICh0aGlzLmRhdGFiYXNlIGluc3RhbmNlb2YgTWVtb3J5RGF0YWJhc2UpIHtcblxuICAgICAgcmV0dXJuICdtZW1vcnknO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcmV0dXJuICd1bmtub3duJztcblxuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIEluZm8gYWJvdXQgYGluZGV4ZWREQmAgZGF0YWJhc2UuICpPbmx5IHVzZWZ1bCBmb3IgaW50ZXJvcGVyYWJpbGl0eS4qXG4gICAqIEByZXR1cm5zIGBpbmRleGVkREJgIGRhdGFiYXNlIG5hbWUsIHN0b3JlIG5hbWUgYW5kIGRhdGFiYXNlIHZlcnNpb24uXG4gICAqICoqVmFsdWVzIHdpbGwgYmUgZW1wdHkgaWYgdGhlIHN0b3JhZ2UgaXMgbm90IGBpbmRleGVkREJgLCoqXG4gICAqICoqc28gaXQgc2hvdWxkIGJlIHVzZWQgYWZ0ZXIgYW4gZW5naW5lIGNoZWNrKiouXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvYmxvYi9tYXN0ZXIvZG9jcy9JTlRFUk9QRVJBQklMSVRZLm1kfVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpZiAodGhpcy5zdG9yYWdlTWFwLmJhY2tpbmdFbmdpbmUgPT09ICdpbmRleGVkREInKSB7XG4gICAqICAgY29uc3QgeyBkYXRhYmFzZSwgc3RvcmUsIHZlcnNpb24gfSA9IHRoaXMuc3RvcmFnZU1hcC5iYWNraW5nU3RvcmU7XG4gICAqIH1cbiAgICovXG4gIGdldCBiYWNraW5nU3RvcmUoKTogeyBkYXRhYmFzZTogc3RyaW5nLCBzdG9yZTogc3RyaW5nLCB2ZXJzaW9uOiBudW1iZXIgfSB7XG5cbiAgICByZXR1cm4gKHRoaXMuZGF0YWJhc2UgaW5zdGFuY2VvZiBJbmRleGVkREJEYXRhYmFzZSkgP1xuICAgICAgdGhpcy5kYXRhYmFzZS5iYWNraW5nU3RvcmUgOlxuICAgICAgeyBkYXRhYmFzZTogJycsIHN0b3JlOiAnJywgdmVyc2lvbjogMCB9O1xuXG4gIH1cblxuICAvKipcbiAgICogSW5mbyBhYm91dCBgbG9jYWxTdG9yYWdlYCBmYWxsYmFjayBzdG9yYWdlLiAqT25seSB1c2VmdWwgZm9yIGludGVyb3BlcmFiaWxpdHkuKlxuICAgKiBAcmV0dXJucyBgbG9jYWxTdG9yYWdlYCBwcmVmaXguXG4gICAqICoqVmFsdWVzIHdpbGwgYmUgZW1wdHkgaWYgdGhlIHN0b3JhZ2UgaXMgbm90IGBsb2NhbFN0b3JhZ2VgLCoqXG4gICAqICoqc28gaXQgc2hvdWxkIGJlIHVzZWQgYWZ0ZXIgYW4gZW5naW5lIGNoZWNrKiouXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvYmxvYi9tYXN0ZXIvZG9jcy9JTlRFUk9QRVJBQklMSVRZLm1kfVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpZiAodGhpcy5zdG9yYWdlTWFwLmJhY2tpbmdFbmdpbmUgPT09ICdsb2NhbFN0b3JhZ2UnKSB7XG4gICAqICAgY29uc3QgeyBwcmVmaXggfSA9IHRoaXMuc3RvcmFnZU1hcC5mYWxsYmFja0JhY2tpbmdTdG9yZTtcbiAgICogfVxuICAgKi9cbiAgZ2V0IGZhbGxiYWNrQmFja2luZ1N0b3JlKCk6IHsgcHJlZml4OiBzdHJpbmcgfSB7XG5cbiAgICByZXR1cm4gKHRoaXMuZGF0YWJhc2UgaW5zdGFuY2VvZiBMb2NhbFN0b3JhZ2VEYXRhYmFzZSkgP1xuICAgICAgeyBwcmVmaXg6IHRoaXMuZGF0YWJhc2UucHJlZml4IH0gOlxuICAgICAgeyBwcmVmaXg6ICcnIH07XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaXRlbSB2YWx1ZSBpbiBzdG9yYWdlLlxuICAgKiBUaGUgc2lnbmF0dXJlIGhhcyBtYW55IG92ZXJsb2FkcyBkdWUgdG8gdmFsaWRhdGlvbiwgKipwbGVhc2UgcmVmZXIgdG8gdGhlIGRvY3VtZW50YXRpb24uKipcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9ibG9iL21hc3Rlci9kb2NzL1ZBTElEQVRJT04ubWR9XG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHBhcmFtIHNjaGVtYSBPcHRpb25hbCBKU09OIHNjaGVtYSB0byB2YWxpZGF0ZSB0aGUgZGF0YVxuICAgKiBAcmV0dXJucyBUaGUgaXRlbSdzIHZhbHVlIGlmIHRoZSBrZXkgZXhpc3RzLCBgdW5kZWZpbmVkYCBvdGhlcndpc2UsIHdyYXBwZWQgaW4gYSBSeEpTIGBPYnNlcnZhYmxlYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLnN0b3JhZ2VNYXAuZ2V0KCdrZXknLCB7IHR5cGU6ICdzdHJpbmcnIH0pLnN1YnNjcmliZSgocmVzdWx0KSA9PiB7XG4gICAqICAgcmVzdWx0OyAvLyBzdHJpbmcgb3IgdW5kZWZpbmVkXG4gICAqIH0pO1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbnRlcmZhY2UgVXNlciB7XG4gICAqICAgZmlyc3ROYW1lOiBzdHJpbmc7XG4gICAqICAgbGFzdE5hbWU/OiBzdHJpbmc7XG4gICAqIH1cbiAgICpcbiAgICogY29uc3Qgc2NoZW1hID0ge1xuICAgKiAgIHR5cGU6ICdvYmplY3QnLFxuICAgKiAgIHByb3BlcnRpZXM6IHtcbiAgICogICAgIGZpcnN0TmFtZTogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgKiAgICAgbGFzdE5hbWU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICogICB9LFxuICAgKiAgIHJlcXVpcmVkOiBbJ2ZpcnN0TmFtZSddXG4gICAqIH07XG4gICAqXG4gICAqIHRoaXMuc3RvcmFnZU1hcC5nZXQ8VXNlcj4oJ3VzZXInLCBzY2hlbWEpLnN1YnNjcmliZSgodXNlcikgPT4ge1xuICAgKiAgIGlmICh1c2VyKSB7XG4gICAqICAgICB1c2VyLmZpcnN0TmFtZTtcbiAgICogICB9XG4gICAqIH0pO1xuICAgKi9cbiAgZ2V0PFQgPSBzdHJpbmc+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFTdHJpbmcpOiBPYnNlcnZhYmxlPHN0cmluZyB8IHVuZGVmaW5lZD47XG4gIGdldDxUID0gbnVtYmVyPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hSW50ZWdlcsKgfCBKU09OU2NoZW1hTnVtYmVyKTogT2JzZXJ2YWJsZTxudW1iZXIgfCB1bmRlZmluZWQ+O1xuICBnZXQ8VCA9IGJvb2xlYW4+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFCb29sZWFuKTogT2JzZXJ2YWJsZTxib29sZWFuIHwgdW5kZWZpbmVkPjtcbiAgZ2V0PFQgPSBzdHJpbmdbXT4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUFycmF5T2Y8SlNPTlNjaGVtYVN0cmluZz4pOiBPYnNlcnZhYmxlPHN0cmluZ1tdIHwgdW5kZWZpbmVkPjtcbiAgZ2V0PFQgPSBudW1iZXJbXT4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUFycmF5T2Y8SlNPTlNjaGVtYUludGVnZXLCoHwgSlNPTlNjaGVtYU51bWJlcj4pOiBPYnNlcnZhYmxlPG51bWJlcltdIHwgdW5kZWZpbmVkPjtcbiAgZ2V0PFQgPSBib29sZWFuW10+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFBcnJheU9mPEpTT05TY2hlbWFCb29sZWFuPik6IE9ic2VydmFibGU8Ym9vbGVhbltdIHwgdW5kZWZpbmVkPjtcbiAgZ2V0PFQgPSBhbnk+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWEpOiBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+O1xuICBnZXQ8VCA9IHVua25vd24+KGtleTogc3RyaW5nLCBzY2hlbWE/OiBKU09OU2NoZW1hKTogT2JzZXJ2YWJsZTx1bmtub3duPjtcbiAgZ2V0PFQgPSBhbnk+KGtleTogc3RyaW5nLCBzY2hlbWE/OiBKU09OU2NoZW1hKSB7XG5cbiAgICAvKiBHZXQgdGhlIGRhdGEgaW4gc3RvcmFnZSAqL1xuICAgIHJldHVybiB0aGlzLmRhdGFiYXNlLmdldDxUPihrZXkpLnBpcGUoXG4gICAgICAvKiBDaGVjayBpZiBgaW5kZXhlZERiYCBpcyBicm9rZW4gKi9cbiAgICAgIHRoaXMuY2F0Y2hJREJCcm9rZW4oKCkgPT4gdGhpcy5kYXRhYmFzZS5nZXQ8VD4oa2V5KSksXG4gICAgICBtZXJnZU1hcCgoZGF0YSkgPT4ge1xuXG4gICAgICAgIC8qIE5vIG5lZWQgdG8gdmFsaWRhdGUgaWYgdGhlIGRhdGEgaXMgZW1wdHkgKi9cbiAgICAgICAgaWYgKChkYXRhID09PSB1bmRlZmluZWQpIHx8IChkYXRhID09PSBudWxsKSkge1xuXG4gICAgICAgICAgcmV0dXJuIG9mKHVuZGVmaW5lZCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChzY2hlbWEpIHtcblxuICAgICAgICAgIC8qIFZhbGlkYXRlIGRhdGEgYWdhaW5zdCBhIEpTT04gc2NoZW1hIGlmIHByb3ZpZGVkICovXG4gICAgICAgICAgaWYgKCF0aGlzLmpzb25WYWxpZGF0b3IudmFsaWRhdGUoZGF0YSwgc2NoZW1hKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IobmV3IFZhbGlkYXRpb25FcnJvcigpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKiBEYXRhIGhhdmUgYmVlbiBjaGVja2VkLCBzbyBpdCdzIE9LIHRvIGNhc3QgKi9cbiAgICAgICAgICByZXR1cm4gb2YoZGF0YSBhcyBUIHwgdW5kZWZpbmVkKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLyogQ2FzdCB0byB1bmtub3duIGFzIHRoZSBkYXRhIHdhc24ndCBjaGVja2VkICovXG4gICAgICAgIHJldHVybiBvZihkYXRhIGFzIHVua25vd24pO1xuXG4gICAgICB9KSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogU2V0IGFuIGl0ZW0gaW4gc3RvcmFnZS5cbiAgICogTm90ZSB0aGF0IHNldHRpbmcgYG51bGxgIG9yIGB1bmRlZmluZWRgIHdpbGwgcmVtb3ZlIHRoZSBpdGVtIHRvIGF2b2lkIHNvbWUgYnJvd3NlcnMgaXNzdWVzLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEBwYXJhbSBkYXRhIFRoZSBpdGVtJ3MgdmFsdWVcbiAgICogQHBhcmFtIHNjaGVtYSBPcHRpb25hbCBKU09OIHNjaGVtYSB0byB2YWxpZGF0ZSB0aGUgZGF0YVxuICAgKiBAcmV0dXJucyBBIFJ4SlMgYE9ic2VydmFibGVgIHRvIHdhaXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMuc3RvcmFnZU1hcC5zZXQoJ2tleScsICd2YWx1ZScpLnN1YnNjcmliZSgoKSA9PiB7fSk7XG4gICAqL1xuICBzZXQoa2V5OiBzdHJpbmcsIGRhdGE6IGFueSwgc2NoZW1hPzogSlNPTlNjaGVtYSk6IE9ic2VydmFibGU8dW5kZWZpbmVkPiB7XG5cbiAgICAvKiBTdG9yaW5nIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpcyB1c2VsZXNzIGFuZCBjYW4gY2F1c2UgaXNzdWVzIGluIGBpbmRleGVkRGJgIGluIHNvbWUgYnJvd3NlcnMsXG4gICAgICogc28gcmVtb3ZpbmcgaXRlbSBpbnN0ZWFkIGZvciBhbGwgc3RvcmFnZXMgdG8gaGF2ZSBhIGNvbnNpc3RlbnQgQVBJICovXG4gICAgaWYgKChkYXRhID09PSB1bmRlZmluZWQpIHx8IChkYXRhID09PSBudWxsKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgfVxuXG4gICAgLyogVmFsaWRhdGUgZGF0YSBhZ2FpbnN0IGEgSlNPTiBzY2hlbWEgaWYgcHJvdmlkZWQgKi9cbiAgICBpZiAoc2NoZW1hICYmICF0aGlzLmpzb25WYWxpZGF0b3IudmFsaWRhdGUoZGF0YSwgc2NoZW1hKSkge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IobmV3IFZhbGlkYXRpb25FcnJvcigpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhYmFzZS5zZXQoa2V5LCBkYXRhKVxuICAgICAgLyogQ2F0Y2ggaWYgYGluZGV4ZWREYmAgaXMgYnJva2VuICovXG4gICAgICAucGlwZSh0aGlzLmNhdGNoSURCQnJva2VuKCgpID0+IHRoaXMuZGF0YWJhc2Uuc2V0KGtleSwgZGF0YSkpKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhbiBpdGVtIGluIHN0b3JhZ2VcbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgKiBAcmV0dXJucyBBIFJ4SlMgYE9ic2VydmFibGVgIHRvIHdhaXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMuc3RvcmFnZU1hcC5kZWxldGUoJ2tleScpLnN1YnNjcmliZSgoKSA9PiB7fSk7XG4gICAqL1xuICBkZWxldGUoa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPHVuZGVmaW5lZD4ge1xuXG4gICAgcmV0dXJuIHRoaXMuZGF0YWJhc2UuZGVsZXRlKGtleSlcbiAgICAgIC8qIENhdGNoIGlmIGBpbmRleGVkRGJgIGlzIGJyb2tlbiAqL1xuICAgICAgLnBpcGUodGhpcy5jYXRjaElEQkJyb2tlbigoKSA9PiB0aGlzLmRhdGFiYXNlLmRlbGV0ZShrZXkpKSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYWxsIGl0ZW1zIGluIHN0b3JhZ2VcbiAgICogQHJldHVybnMgQSBSeEpTIGBPYnNlcnZhYmxlYCB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLnN0b3JhZ2VNYXAuY2xlYXIoKS5zdWJzY3JpYmUoKCkgPT4ge30pO1xuICAgKi9cbiAgY2xlYXIoKTogT2JzZXJ2YWJsZTx1bmRlZmluZWQ+IHtcblxuICAgIHJldHVybiB0aGlzLmRhdGFiYXNlLmNsZWFyKClcbiAgICAgIC8qIENhdGNoIGlmIGBpbmRleGVkRGJgIGlzIGJyb2tlbiAqL1xuICAgICAgLnBpcGUodGhpcy5jYXRjaElEQkJyb2tlbigoKSA9PiB0aGlzLmRhdGFiYXNlLmNsZWFyKCkpKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwga2V5cyBzdG9yZWQgaW4gc3RvcmFnZS4gTm90ZSAqKnRoaXMgaXMgYW4gKml0ZXJhdGluZyogYE9ic2VydmFibGVgKio6XG4gICAqICogaWYgdGhlcmUgaXMgbm8ga2V5LCB0aGUgYG5leHRgIGNhbGxiYWNrIHdpbGwgbm90IGJlIGludm9rZWQsXG4gICAqICogaWYgeW91IG5lZWQgdG8gd2FpdCB0aGUgd2hvbGUgb3BlcmF0aW9uIHRvIGVuZCwgYmUgc3VyZSB0byBhY3QgaW4gdGhlIGBjb21wbGV0ZWAgY2FsbGJhY2ssXG4gICAqIGFzIHRoaXMgYE9ic2VydmFibGVgIGNhbiBlbWl0IHNldmVyYWwgdmFsdWVzIGFuZCBzbyB3aWxsIGludm9rZSB0aGUgYG5leHRgIGNhbGxiYWNrIHNldmVyYWwgdGltZXMuXG4gICAqIEByZXR1cm5zIEEgbGlzdCBvZiB0aGUga2V5cyB3cmFwcGVkIGluIGEgUnhKUyBgT2JzZXJ2YWJsZWBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5zdG9yYWdlTWFwLmtleXMoKS5zdWJzY3JpYmUoe1xuICAgKiAgIG5leHQ6IChrZXkpID0+IHsgY29uc29sZS5sb2coa2V5KTsgfSxcbiAgICogICBjb21wbGV0ZTogKCkgPT4geyBjb25zb2xlLmxvZygnRG9uZScpOyB9LFxuICAgKiB9KTtcbiAgICovXG4gIGtleXMoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblxuICAgIHJldHVybiB0aGlzLmRhdGFiYXNlLmtleXMoKVxuICAgICAgLyogQ2F0Y2ggaWYgYGluZGV4ZWREYmAgaXMgYnJva2VuICovXG4gICAgICAucGlwZSh0aGlzLmNhdGNoSURCQnJva2VuKCgpID0+IHRoaXMuZGF0YWJhc2Uua2V5cygpKSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBUZWxscyBpZiBhIGtleSBleGlzdHMgaW4gc3RvcmFnZVxuICAgKiBAcmV0dXJucyBBIFJ4SlMgYE9ic2VydmFibGVgIHRlbGxpbmcgaWYgdGhlIGtleSBleGlzdHNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5zdG9yYWdlTWFwLmhhcygna2V5Jykuc3Vic2NyaWJlKChoYXNLZXkpID0+IHtcbiAgICogICBpZiAoaGFzS2V5KSB7fVxuICAgKiB9KTtcbiAgICovXG4gIGhhcyhrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuXG4gICAgcmV0dXJuIHRoaXMuZGF0YWJhc2UuaGFzKGtleSlcbiAgICAgIC8qIENhdGNoIGlmIGBpbmRleGVkRGJgIGlzIGJyb2tlbiAqL1xuICAgICAgLnBpcGUodGhpcy5jYXRjaElEQkJyb2tlbigoKSA9PiB0aGlzLmRhdGFiYXNlLmhhcyhrZXkpKSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBSeEpTIG9wZXJhdG9yIHRvIGNhdGNoIGlmIGBpbmRleGVkREJgIGlzIGJyb2tlblxuICAgKiBAcGFyYW0gb3BlcmF0aW9uQ2FsbGJhY2sgQ2FsbGJhY2sgd2l0aCB0aGUgb3BlcmF0aW9uIHRvIHJlZG9cbiAgICovXG4gIHByb3RlY3RlZCBjYXRjaElEQkJyb2tlbjxUPihvcGVyYXRpb25DYWxsYmFjazogKCkgPT4gT2JzZXJ2YWJsZTxUPik6IE9wZXJhdG9yRnVuY3Rpb248VCwgVD4ge1xuXG4gICAgcmV0dXJuIGNhdGNoRXJyb3IoKGVycm9yKSA9PiB7XG5cbiAgICAgIC8qIENoZWNrIGlmIGBpbmRleGVkREJgIGlzIGJyb2tlbiBiYXNlZCBvbiBlcnJvciBtZXNzYWdlICh0aGUgc3BlY2lmaWMgZXJyb3IgY2xhc3Mgc2VlbXMgdG8gYmUgbG9zdCBpbiB0aGUgcHJvY2VzcykgKi9cbiAgICAgIGlmICgoZXJyb3IgIT09IHVuZGVmaW5lZCkgJiYgKGVycm9yICE9PSBudWxsKSAmJiAoZXJyb3IubWVzc2FnZSA9PT0gSURCX0JST0tFTl9FUlJPUikpIHtcblxuICAgICAgICAvKiBXaGVuIHN0b3JhZ2UgaXMgZnVsbHkgZGlzYWJsZWQgaW4gYnJvd3NlciAodmlhIHRoZSBcIkJsb2NrIGFsbCBjb29raWVzXCIgb3B0aW9uKSxcbiAgICAgICAgICoganVzdCB0cnlpbmcgdG8gY2hlY2sgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgY2F1c2VzIGEgc2VjdXJpdHkgZXhjZXB0aW9uLlxuICAgICAgICAgKiBQcmV2ZW50cyBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2lzc3Vlcy8xMThcbiAgICAgICAgICovXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICBpZiAoJ2dldEl0ZW0nIGluIGxvY2FsU3RvcmFnZSkge1xuXG4gICAgICAgICAgICAvKiBGYWxsYmFjayB0byBgbG9jYWxTdG9yYWdlYCBpZiBhdmFpbGFibGUgKi9cbiAgICAgICAgICAgIHRoaXMuZGF0YWJhc2UgPSBuZXcgTG9jYWxTdG9yYWdlRGF0YWJhc2UodGhpcy5MU1ByZWZpeCwgdGhpcy5vbGRQcmVmaXgpO1xuXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLyogRmFsbGJhY2sgdG8gbWVtb3J5IHN0b3JhZ2Ugb3RoZXJ3aXNlICovXG4gICAgICAgICAgICB0aGlzLmRhdGFiYXNlID0gbmV3IE1lbW9yeURhdGFiYXNlKCk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBjYXRjaCB7XG5cbiAgICAgICAgICAvKiBGYWxsYmFjayB0byBtZW1vcnkgc3RvcmFnZSBvdGhlcndpc2UgKi9cbiAgICAgICAgICB0aGlzLmRhdGFiYXNlID0gbmV3IE1lbW9yeURhdGFiYXNlKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFJlZG8gdGhlIG9wZXJhdGlvbiAqL1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uQ2FsbGJhY2soKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvKiBPdGhlcndpc2UsIHJldGhyb3cgdGhlIGVycm9yICovXG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycm9yKTtcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgfVxuXG59XG4iXX0=