import * as tslib_1 from "tslib";
import { Injectable, Inject } from '@angular/core';
import { ReplaySubject, fromEvent, of, throwError, race } from 'rxjs';
import { map, mergeMap, first, takeWhile, tap } from 'rxjs/operators';
import { IDBBrokenError } from './exceptions';
import { IDB_DB_NAME, IDB_STORE_NAME, DEFAULT_IDB_STORE_NAME, IDB_DB_VERSION, LOCAL_STORAGE_PREFIX, DEFAULT_IDB_DB_NAME, DEFAULT_IDB_DB_VERSION, IDB_NO_WRAP, DEFAULT_IDB_NO_WRAP } from '../tokens';
import * as i0 from "@angular/core";
import * as i1 from "../tokens";
let IndexedDBDatabase = class IndexedDBDatabase {
    /**
     * Constructor params are provided by Angular (but can also be passed manually in tests)
     * @param dbName `indexedDB` database name
     * @param storeName `indexedDB` store name
     * @param dbVersion `indexedDB` database version
     * @param noWrap `indexedDB` database version
     * @param oldPrefix Pre-v8 backward compatible prefix
     */
    constructor(dbName = DEFAULT_IDB_DB_NAME, storeName = DEFAULT_IDB_STORE_NAME, dbVersion = DEFAULT_IDB_DB_VERSION, noWrap = DEFAULT_IDB_NO_WRAP, 
    // tslint:disable-next-line: deprecation
    oldPrefix = '') {
        /**
         * `indexedDB` database connection, wrapped in a RxJS `ReplaySubject` to be able to access the connection
         * even after the connection success event happened
         */
        this.database = new ReplaySubject(1);
        /**
         * Index used when wrapping value. *For backward compatibility only.*
         */
        this.wrapIndex = 'value';
        /* Initialize `indexedDB` database name, with prefix if provided by the user */
        this.dbName = oldPrefix ? `${oldPrefix}_${dbName}` : dbName;
        this.storeName = storeName;
        this.dbVersion = dbVersion;
        this.noWrap = noWrap;
        /* Connect to `indexedDB`, with prefix if provided by the user */
        this.connect();
    }
    /**
     * Information about `indexedDB` connection. *Only useful for interoperability.*
     * @returns `indexedDB` database name, store name and database version
     */
    get backingStore() {
        return {
            database: this.dbName,
            store: this.storeName,
            version: this.dbVersion,
        };
    }
    /**
     * Number of items in our `indexedDB` database and object store
     */
    get size() {
        /* Open a transaction in read-only mode */
        return this.transaction('readonly').pipe(mergeMap((store) => {
            /* Request to know the number of items */
            const request = store.count();
            /* Manage success and error events, and get the result */
            return this.requestEventsAndMapTo(request, () => request.result);
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Gets an item value in our `indexedDB` store
     * @param key The item's key
     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in an RxJS `Observable`
     */
    get(key) {
        /* Open a transaction in read-only mode */
        return this.transaction('readonly').pipe(mergeMap((store) => {
            /* Request the value with the key provided by the user */
            const request = store.get(key);
            /* Manage success and error events, and get the result */
            return this.requestEventsAndMapTo(request, () => {
                if ((request.result !== undefined) && (request.result !== null)) {
                    /* Prior to v8, the value was wrapped in an `{ value: ...}` object */
                    if (!this.noWrap && (typeof request.result === 'object') && (this.wrapIndex in request.result) &&
                        (request.result[this.wrapIndex] !== undefined) && (request.result[this.wrapIndex] !== null)) {
                        return request.result[this.wrapIndex];
                    }
                    else {
                        /* Cast to the wanted type */
                        return request.result;
                    }
                }
                /* Return `undefined` if the value is empty */
                return undefined;
            });
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Sets an item in our `indexedDB` store
     * @param key The item's key
     * @param data The item's value
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    set(key, data) {
        /* Storing `undefined` in `indexedDb` can cause issues in some browsers so removing item instead */
        if (data === undefined) {
            return this.delete(key);
        }
        /* Open a transaction in write mode */
        return this.transaction('readwrite').pipe(mergeMap((store) => {
            /* Check if the key already exists or not
             * `getKey()` is better but only available in `indexedDB` v2 (Chrome >= 58, missing in IE/Edge).
             * In older browsers, the value is checked instead, but it could lead to an exception
             * if `undefined` was stored outside of this lib (e.g. directly with the native `indexedDB` API).
             */
            const requestGet = this.getKeyRequest(store, key);
            /* Manage success and error events, and get the request result */
            return this.requestEventsAndMapTo(requestGet, () => requestGet.result).pipe(mergeMap((existingEntry) => {
                /* It is very important the second request is done from the same transaction/store as the previous one,
                 * otherwise it could lead to concurrency failures
                 * Avoid https://github.com/cyrilletuzi/angular-async-local-storage/issues/47 */
                /* Prior to v8, data was wrapped in a `{ value: ... }` object */
                const dataToStore = this.noWrap ? data : { [this.wrapIndex]: data };
                /* Add if the item is not existing yet, or update otherwise */
                const requestSet = (existingEntry === undefined) ?
                    store.add(dataToStore, key) :
                    store.put(dataToStore, key);
                /* Manage success and error events, and map to `true` */
                return this.requestEventsAndMapTo(requestSet, () => undefined);
            }));
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Deletes an item in our `indexedDB` store
     * @param key The item's key
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    delete(key) {
        /* Open a transaction in write mode */
        return this.transaction('readwrite').pipe(mergeMap((store) => {
            /* Deletethe item in store */
            const request = store.delete(key);
            /* Manage success and error events, and map to `true` */
            return this.requestEventsAndMapTo(request, () => undefined);
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Deletes all items from our `indexedDB` objet store
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    clear() {
        /* Open a transaction in write mode */
        return this.transaction('readwrite').pipe(mergeMap((store) => {
            /* Delete all items in object store */
            const request = store.clear();
            /* Manage success and error events, and map to `true` */
            return this.requestEventsAndMapTo(request, () => undefined);
        }), 
        /* The observable will complete */
        first());
    }
    /**
     * Get all the keys in our `indexedDB` store
     * @returns An RxJS `Observable` iterating on each key
     */
    keys() {
        /* Open a transaction in read-only mode */
        return this.transaction('readonly').pipe(
        /* `first()` is used as the final operator in other methods to complete the `Observable`
         * (as it all starts from a `ReplaySubject` which never ends),
         * but as this method is iterating over multiple values, `first()` **must** be used here */
        first(), mergeMap((store) => {
            /* Open a cursor on the store
             * `.openKeyCursor()` is better for performance, but only available in indexedDB v2 (missing in IE/Edge)
             * Avoid issues like https://github.com/cyrilletuzi/angular-async-local-storage/issues/69 */
            const request = ('openKeyCursor' in store) ? store.openKeyCursor() : store.openCursor();
            /* Listen to success event */
            const success$ = this.successEvent(request).pipe(
            /* Stop the `Observable` when the cursor is `null` */
            takeWhile(() => (request.result !== null)), 
            /* This lib only allows string keys, but user could have added other types of keys from outside
             * It's OK to cast as the cursor as been tested in the previous operator */
            map(() => request.result.key.toString()), 
            /* Iterate on the cursor */
            tap(() => { request.result.continue(); }));
            /* Listen to error event and if so, throw an error */
            const error$ = this.errorEvent(request);
            /* Choose the first event to occur */
            return race([success$, error$]);
        }));
    }
    /**
     * Check if a key exists in our `indexedDB` store
     * @returns An RxJS `Observable` telling if the key exists or not
     */
    has(key) {
        /* Open a transaction in read-only mode */
        return this.transaction('readonly').pipe(mergeMap((store) => {
            /* Check if the key exists in the store */
            const request = this.getKeyRequest(store, key);
            /* Manage success and error events, and map to a boolean based on the existence of the key */
            return this.requestEventsAndMapTo(request, () => (request.result !== undefined) ? true : false);
        }), 
        /* The observable will complete */
        first());
    }
    /**
     * Connects to `indexedDB` and creates the object store on first time
     */
    connect() {
        let request;
        /* Connect to `indexedDB`
         * Will fail in Safari cross-origin iframes
         * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42} */
        try {
            /* Do NOT explicit `window` here, as `indexedDB` could be used from a web worker too */
            request = indexedDB.open(this.dbName, this.dbVersion);
        }
        catch (_a) {
            this.database.error(new IDBBrokenError());
            return;
        }
        /* Create store on first connection */
        this.createStore(request);
        /* Listen to success and error events and choose the first to occur */
        race([this.successEvent(request), this.errorEvent(request)])
            /* The observable will complete */
            .pipe(first())
            .subscribe({
            next: () => {
                /* Register the database connection in the `ReplaySubject` for further access */
                this.database.next(request.result);
            },
            error: () => {
                /* Firefox private mode issue: fallback storage if IndexedDb connection is failing
                * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}
                * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/26} */
                this.database.error(new IDBBrokenError());
            },
        });
    }
    /**
     * Create store on first use of `indexedDB`
     * @param request `indexedDB` database opening request
     */
    createStore(request) {
        /* Listen to the event fired on first connection */
        fromEvent(request, 'upgradeneeded')
            /* The observable will complete */
            .pipe(first())
            .subscribe({
            next: () => {
                /* Check if the store already exists, to avoid error */
                if (!request.result.objectStoreNames.contains(this.storeName)) {
                    /* Create the object store */
                    request.result.createObjectStore(this.storeName);
                }
            }
        });
    }
    /**
     * Open an `indexedDB` transaction and get our store
     * @param mode `readonly` or `readwrite`
     * @returns An `indexedDB` store, wrapped in an RxJS `Observable`
     */
    transaction(mode) {
        /* From the `indexedDB` connection, open a transaction and get the store */
        return this.database
            .pipe(mergeMap((database) => {
            let store;
            try {
                store = database.transaction([this.storeName], mode).objectStore(this.storeName);
            }
            catch (error) {
                /* The store could have been deleted from outside */
                return throwError(error);
            }
            return of(store);
        }));
    }
    /**
     * Listen to an `indexedDB` success error event
     * @param request Request to listen
     * @returns An RxJS `Observable` listening to the success event
     */
    successEvent(request) {
        return fromEvent(request, 'success');
    }
    /**
     * Listen to an `indexedDB` request error event
     * @param request Request to listen
     * @returns An RxJS `Observable` listening to the error event and if so, throwing an error
     */
    errorEvent(request) {
        return fromEvent(request, 'error').pipe(mergeMap(() => throwError(request.error)));
    }
    /**
     * Listen to an `indexedDB` request success and error event, and map to the wanted value
     * @param request Request to listen
     * @param mapCallback Callback returning the wanted value
     * @returns An RxJS `Observable` listening to request events and mapping to the wanted value
     */
    requestEventsAndMapTo(request, mapCallback) {
        /* Listen to the success event and map to the wanted value
         * `mapTo()` must not be used here as it would eval `request.result` too soon */
        const success$ = this.successEvent(request).pipe(map(mapCallback));
        /* Listen to the error event */
        const error$ = this.errorEvent(request);
        /* Choose the first event to occur */
        return race([success$, error$]);
    }
    /**
     * Check if the key exists in the store
     * @param store Objet store on which to perform the request
     * @param key Key to check
     * @returns An `indexedDB` request
     */
    getKeyRequest(store, key) {
        /* `getKey()` is better but only available in `indexedDB` v2 (Chrome >= 58, missing in IE/Edge).
         * In older browsers, the value is checked instead, but it could lead to an exception
         * if `undefined` was stored outside of this lib (e.g. directly with the native `indexedDB` API).
         * Fixes https://github.com/cyrilletuzi/angular-async-local-storage/issues/69
         */
        return ('getKey' in store) ? store.getKey(key) : store.get(key);
    }
};
IndexedDBDatabase.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function IndexedDBDatabase_Factory() { return new IndexedDBDatabase(i0.ɵɵinject(i1.IDB_DB_NAME), i0.ɵɵinject(i1.IDB_STORE_NAME), i0.ɵɵinject(i1.IDB_DB_VERSION), i0.ɵɵinject(i1.IDB_NO_WRAP), i0.ɵɵinject(i1.LOCAL_STORAGE_PREFIX)); }, token: IndexedDBDatabase, providedIn: "root" });
IndexedDBDatabase = tslib_1.__decorate([
    Injectable({
        providedIn: 'root'
    }),
    tslib_1.__param(0, Inject(IDB_DB_NAME)),
    tslib_1.__param(1, Inject(IDB_STORE_NAME)),
    tslib_1.__param(2, Inject(IDB_DB_VERSION)),
    tslib_1.__param(3, Inject(IDB_NO_WRAP)),
    tslib_1.__param(4, Inject(LOCAL_STORAGE_PREFIX)),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object, Object, Object])
], IndexedDBDatabase);
export { IndexedDBDatabase };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXhlZGRiLWRhdGFiYXNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neC1wd2EvbG9jYWwtc3RvcmFnZS8iLCJzb3VyY2VzIjpbImxpYi9kYXRhYmFzZXMvaW5kZXhlZGRiLWRhdGFiYXNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBQWMsYUFBYSxFQUFFLFNBQVMsRUFBRSxFQUFFLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNsRixPQUFPLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBR3RFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDOUMsT0FBTyxFQUNMLFdBQVcsRUFBRSxjQUFjLEVBQUUsc0JBQXNCLEVBQUUsY0FBYyxFQUFFLG9CQUFvQixFQUN6RixtQkFBbUIsRUFBRSxzQkFBc0IsRUFBRSxXQUFXLEVBQUUsbUJBQW1CLEVBQzlFLE1BQU0sV0FBVyxDQUFDOzs7QUFLbkIsSUFBYSxpQkFBaUIsR0FBOUIsTUFBYSxpQkFBaUI7SUFpQzVCOzs7Ozs7O09BT0c7SUFDSCxZQUN1QixTQUFTLG1CQUFtQixFQUN6QixZQUFZLHNCQUFzQixFQUNsQyxZQUFZLHNCQUFzQixFQUNyQyxTQUFTLG1CQUFtQjtJQUNqRCx3Q0FBd0M7SUFDVixZQUFZLEVBQUU7UUE5QjlDOzs7V0FHRztRQUNnQixhQUFRLEdBQUcsSUFBSSxhQUFhLENBQWMsQ0FBQyxDQUFDLENBQUM7UUFPaEU7O1dBRUc7UUFDZ0IsY0FBUyxHQUFHLE9BQU8sQ0FBQztRQW1CckMsK0VBQStFO1FBQy9FLElBQUksQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVMsSUFBSSxNQUFNLEVBQUUsQ0FBQyxD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QUNoRixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztRQUVuRSwrQkFBK0I7UUFDL0IsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUV4QyxxQ0FBcUM7UUFDckMsT0FBTyxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUVsQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDTyxhQUFhLENBQUMsS0FBcUIsRUFBRSxHQUFXO1FBRXhEOzs7O1dBSUc7UUFDSCxPQUFPLENBQUMsUUFBUSxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBRSxLQUF3QixDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUV0RixDQUFDO0NBRUYsQ0FBQTs7QUFuZFksaUJBQWlCO0lBSDdCLFVBQVUsQ0FBQztRQUNWLFVBQVUsRUFBRSxNQUFNO0tBQ25CLENBQUM7SUEyQ0csbUJBQUEsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFBO0lBQ25CLG1CQUFBLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQTtJQUN0QixtQkFBQSxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUE7SUFDdEIsbUJBQUEsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFBO0lBRW5CLG1CQUFBLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFBOztHQS9DcEIsaUJBQWlCLENBbWQ3QjtTQW5kWSxpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFJlcGxheVN1YmplY3QsIGZyb21FdmVudCwgb2YsIHRocm93RXJyb3IsIHJhY2UgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgbWVyZ2VNYXAsIGZpcnN0LCB0YWtlV2hpbGUsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgTG9jYWxEYXRhYmFzZSB9IGZyb20gJy4vbG9jYWwtZGF0YWJhc2UnO1xuaW1wb3J0IHsgSURCQnJva2VuRXJyb3IgfSBmcm9tICcuL2V4Y2VwdGlvbnMnO1xuaW1wb3J0IHtcbiAgSURCX0RCX05BTUUsIElEQl9TVE9SRV9OQU1FLCBERUZBVUxUX0lEQl9TVE9SRV9OQU1FLCBJREJfREJfVkVSU0lPTiwgTE9DQUxfU1RPUkFHRV9QUkVGSVgsXG4gIERFRkFVTFRfSURCX0RCX05BTUUsIERFRkFVTFRfSURCX0RCX1ZFUlNJT04sIElEQl9OT19XUkFQLCBERUZBVUxUX0lEQl9OT19XUkFQXG59IGZyb20gJy4uL3Rva2Vucyc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIEluZGV4ZWREQkRhdGFiYXNlIGltcGxlbWVudHMgTG9jYWxEYXRhYmFzZSB7XG5cbiAgLyoqXG4gICAqIGBpbmRleGVkREJgIGRhdGFiYXNlIG5hbWVcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBkYk5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogYGluZGV4ZWREQmAgb2JqZWN0IHN0b3JlIG5hbWVcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBzdG9yZU5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogYGluZGV4ZWREQmAgZGF0YWJhc2UgdmVyc2lvbi4gTXVzdCBiZSBhbiB1bnNpZ25lZCAqKmludGVnZXIqKlxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGRiVmVyc2lvbjogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBgaW5kZXhlZERCYCBkYXRhYmFzZSBjb25uZWN0aW9uLCB3cmFwcGVkIGluIGEgUnhKUyBgUmVwbGF5U3ViamVjdGAgdG8gYmUgYWJsZSB0byBhY2Nlc3MgdGhlIGNvbm5lY3Rpb25cbiAgICogZXZlbiBhZnRlciB0aGUgY29ubmVjdGlvbiBzdWNjZXNzIGV2ZW50IGhhcHBlbmVkXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZGF0YWJhc2UgPSBuZXcgUmVwbGF5U3ViamVjdDxJREJEYXRhYmFzZT4oMSk7XG5cbiAgLyoqXG4gICAqIEZsYWcgdG8gbm90IHdyYXAgYGluZGV4ZWREQmAgdmFsdWVzIGZvciBpbnRlcm9wZXJhYmlsaXR5IG9yIHRvIHdyYXAgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgbm9XcmFwOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJbmRleCB1c2VkIHdoZW4gd3JhcHBpbmcgdmFsdWUuICpGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBvbmx5LipcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSB3cmFwSW5kZXggPSAndmFsdWUnO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBwYXJhbXMgYXJlIHByb3ZpZGVkIGJ5IEFuZ3VsYXIgKGJ1dCBjYW4gYWxzbyBiZSBwYXNzZWQgbWFudWFsbHkgaW4gdGVzdHMpXG4gICAqIEBwYXJhbSBkYk5hbWUgYGluZGV4ZWREQmAgZGF0YWJhc2UgbmFtZVxuICAgKiBAcGFyYW0gc3RvcmVOYW1lIGBpbmRleGVkREJgIHN0b3JlIG5hbWVcbiAgICogQHBhcmFtIGRiVmVyc2lvbiBgaW5kZXhlZERCYCBkYXRhYmFzZSB2ZXJzaW9uXG4gICAqIEBwYXJhbSBub1dyYXAgYGluZGV4ZWREQmAgZGF0YWJhc2UgdmVyc2lvblxuICAgKiBAcGFyYW0gb2xkUHJlZml4IFByZS12OCBiYWNrd2FyZCBjb21wYXRpYmxlIHByZWZpeFxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChJREJfREJfTkFNRSkgZGJOYW1lID0gREVGQVVMVF9JREJfREJfTkFNRSxcbiAgICBASW5qZWN0KElEQl9TVE9SRV9OQU1FKSBzdG9yZU5hbWUgPSBERUZBVUxUX0lEQl9TVE9SRV9OQU1FLFxuICAgIEBJbmplY3QoSURCX0RCX1ZFUlNJT04pIGRiVmVyc2lvbiA9IERFRkFVTFRfSURCX0RCX1ZFUlNJT04sXG4gICAgQEluamVjdChJREJfTk9fV1JBUCkgbm9XcmFwID0gREVGQVVMVF9JREJfTk9fV1JBUCxcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGRlcHJlY2F0aW9uXG4gICAgQEluamVjdChMT0NBTF9TVE9SQUdFX1BSRUZJWCkgb2xkUHJlZml4ID0gJycsXG4gICkge1xuXG4gICAgLyogSW5pdGlhbGl6ZSBgaW5kZXhlZERCYCBkYXRhYmFzZSBuYW1lLCB3aXRoIHByZWZpeCBpZiBwcm92aWRlZCBieSB0aGUgdXNlciAqL1xuICAgIHRoaXMuZGJOYW1lID0gb2xkUHJlZml4ID8gYCR7b2xkUHJlZml4fV8ke2RiTmFtZX1gIDogZGJOYW1lO1xuXG4gICAgdGhpcy5zdG9yZU5hbWUgPSBzdG9yZU5hbWU7XG4gICAgdGhpcy5kYlZlcnNpb24gPSBkYlZlcnNpb247XG4gICAgdGhpcy5ub1dyYXAgPSBub1dyYXA7XG5cbiAgICAvKiBDb25uZWN0IHRvIGBpbmRleGVkREJgLCB3aXRoIHByZWZpeCBpZiBwcm92aWRlZCBieSB0aGUgdXNlciAqL1xuICAgIHRoaXMuY29ubmVjdCgpO1xuXG4gIH1cblxuICAvKipcbiAgICogSW5mb3JtYXRpb24gYWJvdXQgYGluZGV4ZWREQmAgY29ubmVjdGlvbi4gKk9ubHkgdXNlZnVsIGZvciBpbnRlcm9wZXJhYmlsaXR5LipcbiAgICogQHJldHVybnMgYGluZGV4ZWREQmAgZGF0YWJhc2UgbmFtZSwgc3RvcmUgbmFtZSBhbmQgZGF0YWJhc2UgdmVyc2lvblxuICAgKi9cbiAgZ2V0IGJhY2tpbmdTdG9yZSgpOiB7IGRhdGFiYXNlOiBzdHJpbmcsIHN0b3JlOiBzdHJpbmcsIHZlcnNpb246IG51bWJlciB9IHtcblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhYmFzZTogdGhpcy5kYk5hbWUsXG4gICAgICBzdG9yZTogdGhpcy5zdG9yZU5hbWUsXG4gICAgICB2ZXJzaW9uOiB0aGlzLmRiVmVyc2lvbixcbiAgICB9O1xuXG4gIH1cblxuICAvKipcbiAgICogTnVtYmVyIG9mIGl0ZW1zIGluIG91ciBgaW5kZXhlZERCYCBkYXRhYmFzZSBhbmQgb2JqZWN0IHN0b3JlXG4gICAqL1xuICBnZXQgc2l6ZSgpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuXG4gICAgLyogT3BlbiBhIHRyYW5zYWN0aW9uIGluIHJlYWQtb25seSBtb2RlICovXG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24oJ3JlYWRvbmx5JykucGlwZShcbiAgICAgIG1lcmdlTWFwKChzdG9yZSkgPT4ge1xuXG4gICAgICAgIC8qIFJlcXVlc3QgdG8ga25vdyB0aGUgbnVtYmVyIG9mIGl0ZW1zICovXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5jb3VudCgpO1xuXG4gICAgICAgIC8qIE1hbmFnZSBzdWNjZXNzIGFuZCBlcnJvciBldmVudHMsIGFuZCBnZXQgdGhlIHJlc3VsdCAqL1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RXZlbnRzQW5kTWFwVG8ocmVxdWVzdCwgKCkgPT4gcmVxdWVzdC5yZXN1bHQpO1xuXG4gICAgICB9KSxcbiAgICAgIC8qIFRoZSBvYnNlcnZhYmxlIHdpbGwgY29tcGxldGUgYWZ0ZXIgdGhlIGZpcnN0IHZhbHVlICovXG4gICAgICBmaXJzdCgpLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGl0ZW0gdmFsdWUgaW4gb3VyIGBpbmRleGVkREJgIHN0b3JlXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHJldHVybnMgVGhlIGl0ZW0ncyB2YWx1ZSBpZiB0aGUga2V5IGV4aXN0cywgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLCB3cmFwcGVkIGluIGFuIFJ4SlMgYE9ic2VydmFibGVgXG4gICAqL1xuICBnZXQ8VCA9IGFueT4oa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPFTCoHwgdW5kZWZpbmVkPiB7XG5cbiAgICAvKiBPcGVuIGEgdHJhbnNhY3Rpb24gaW4gcmVhZC1vbmx5IG1vZGUgKi9cbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbigncmVhZG9ubHknKS5waXBlKFxuICAgICAgbWVyZ2VNYXAoKHN0b3JlKSA9PiB7XG5cbiAgICAgICAgLyogUmVxdWVzdCB0aGUgdmFsdWUgd2l0aCB0aGUga2V5IHByb3ZpZGVkIGJ5IHRoZSB1c2VyICovXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5nZXQoa2V5KTtcblxuICAgICAgICAvKiBNYW5hZ2Ugc3VjY2VzcyBhbmQgZXJyb3IgZXZlbnRzLCBhbmQgZ2V0IHRoZSByZXN1bHQgKi9cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEV2ZW50c0FuZE1hcFRvKHJlcXVlc3QsICgpID0+IHtcblxuICAgICAgICAgIGlmICgocmVxdWVzdC5yZXN1bHQgIT09IHVuZGVmaW5lZCkgJiYgKHJlcXVlc3QucmVzdWx0ICE9PSBudWxsKSkge1xuXG4gICAgICAgICAgICAvKiBQcmlvciB0byB2OCwgdGhlIHZhbHVlIHdhcyB3cmFwcGVkIGluIGFuIGB7IHZhbHVlOiAuLi59YCBvYmplY3QgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5ub1dyYXAgJiYgKHR5cGVvZiByZXF1ZXN0LnJlc3VsdCA9PT0gJ29iamVjdCcpICYmICh0aGlzLndyYXBJbmRleCBpbiByZXF1ZXN0LnJlc3VsdCkgJiZcbiAgICAgICAgICAgIChyZXF1ZXN0LnJlc3VsdFt0aGlzLndyYXBJbmRleF0gIT09IHVuZGVmaW5lZCkgJiYgKHJlcXVlc3QucmVzdWx0W3RoaXMud3JhcEluZGV4XSAhPT0gbnVsbCkpIHtcblxuICAgICAgICAgICAgICByZXR1cm4gKHJlcXVlc3QucmVzdWx0W3RoaXMud3JhcEluZGV4XSBhcyBUKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAvKiBDYXN0IHRvIHRoZSB3YW50ZWQgdHlwZSAqL1xuICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdC5yZXN1bHQgYXMgVDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyogUmV0dXJuIGB1bmRlZmluZWRgIGlmIHRoZSB2YWx1ZSBpcyBlbXB0eSAqL1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgIH0pLFxuICAgICAgLyogVGhlIG9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSBhZnRlciB0aGUgZmlyc3QgdmFsdWUgKi9cbiAgICAgIGZpcnN0KCksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYW4gaXRlbSBpbiBvdXIgYGluZGV4ZWREQmAgc3RvcmVcbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgKiBAcGFyYW0gZGF0YSBUaGUgaXRlbSdzIHZhbHVlXG4gICAqIEByZXR1cm5zIEFuIFJ4SlMgYE9ic2VydmFibGVgIHRvIHdhaXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uXG4gICAqL1xuICBzZXQoa2V5OiBzdHJpbmcsIGRhdGE6IGFueSk6IE9ic2VydmFibGU8dW5kZWZpbmVkPiB7XG5cbiAgICAvKiBTdG9yaW5nIGB1bmRlZmluZWRgIGluIGBpbmRleGVkRGJgIGNhbiBjYXVzZSBpc3N1ZXMgaW4gc29tZSBicm93c2VycyBzbyByZW1vdmluZyBpdGVtIGluc3RlYWQgKi9cbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxldGUoa2V5KTtcbiAgICB9XG5cbiAgICAvKiBPcGVuIGEgdHJhbnNhY3Rpb24gaW4gd3JpdGUgbW9kZSAqL1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnKS5waXBlKFxuICAgICAgbWVyZ2VNYXAoKHN0b3JlKSA9PiB7XG5cbiAgICAgICAgLyogQ2hlY2sgaWYgdGhlIGtleSBhbHJlYWR5IGV4aXN0cyBvciBub3RcbiAgICAgICAgICogYGdldEtleSgpYCBpcyBiZXR0ZXIgYnV0IG9ubHkgYXZhaWxhYmxlIGluIGBpbmRleGVkREJgIHYyIChDaHJvbWUgPj0gNTgsIG1pc3NpbmcgaW4gSUUvRWRnZSkuXG4gICAgICAgICAqIEluIG9sZGVyIGJyb3dzZXJzLCB0aGUgdmFsdWUgaXMgY2hlY2tlZCBpbnN0ZWFkLCBidXQgaXQgY291bGQgbGVhZCB0byBhbiBleGNlcHRpb25cbiAgICAgICAgICogaWYgYHVuZGVmaW5lZGAgd2FzIHN0b3JlZCBvdXRzaWRlIG9mIHRoaXMgbGliIChlLmcuIGRpcmVjdGx5IHdpdGggdGhlIG5hdGl2ZSBgaW5kZXhlZERCYCBBUEkpLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcmVxdWVzdEdldCA9IHRoaXMuZ2V0S2V5UmVxdWVzdChzdG9yZSwga2V5KTtcblxuICAgICAgICAvKiBNYW5hZ2Ugc3VjY2VzcyBhbmQgZXJyb3IgZXZlbnRzLCBhbmQgZ2V0IHRoZSByZXF1ZXN0IHJlc3VsdCAqL1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RXZlbnRzQW5kTWFwVG8ocmVxdWVzdEdldCwgKCkgPT4gcmVxdWVzdEdldC5yZXN1bHQpLnBpcGUoXG4gICAgICAgICAgbWVyZ2VNYXAoKGV4aXN0aW5nRW50cnkpID0+IHtcblxuICAgICAgICAgICAgLyogSXQgaXMgdmVyeSBpbXBvcnRhbnQgdGhlIHNlY29uZCByZXF1ZXN0IGlzIGRvbmUgZnJvbSB0aGUgc2FtZSB0cmFuc2FjdGlvbi9zdG9yZSBhcyB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAgICAgICogb3RoZXJ3aXNlIGl0IGNvdWxkIGxlYWQgdG8gY29uY3VycmVuY3kgZmFpbHVyZXNcbiAgICAgICAgICAgICAqIEF2b2lkIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvaXNzdWVzLzQ3ICovXG5cbiAgICAgICAgICAgIC8qIFByaW9yIHRvIHY4LCBkYXRhIHdhcyB3cmFwcGVkIGluIGEgYHsgdmFsdWU6IC4uLiB9YCBvYmplY3QgKi9cbiAgICAgICAgICAgIGNvbnN0IGRhdGFUb1N0b3JlID0gdGhpcy5ub1dyYXAgPyBkYXRhIDogeyBbdGhpcy53cmFwSW5kZXhdOiBkYXRhIH07XG5cbiAgICAgICAgICAgIC8qIEFkZCBpZiB0aGUgaXRlbSBpcyBub3QgZXhpc3RpbmcgeWV0LCBvciB1cGRhdGUgb3RoZXJ3aXNlICovXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0U2V0ID0gKGV4aXN0aW5nRW50cnkgPT09IHVuZGVmaW5lZCkgP1xuICAgICAgICAgICAgICBzdG9yZS5hZGQoZGF0YVRvU3RvcmUsIGtleSkgOlxuICAgICAgICAgICAgICBzdG9yZS5wdXQoZGF0YVRvU3RvcmUsIGtleSk7XG5cbiAgICAgICAgICAgIC8qIE1hbmFnZSBzdWNjZXNzIGFuZCBlcnJvciBldmVudHMsIGFuZCBtYXAgdG8gYHRydWVgICovXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RXZlbnRzQW5kTWFwVG8ocmVxdWVzdFNldCwgKCkgPT4gdW5kZWZpbmVkKTtcblxuICAgICAgICAgIH0pLFxuICAgICAgICApO1xuICAgICAgfSksXG4gICAgICAvKiBUaGUgb2JzZXJ2YWJsZSB3aWxsIGNvbXBsZXRlIGFmdGVyIHRoZSBmaXJzdCB2YWx1ZSAqL1xuICAgICAgZmlyc3QoKSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhbiBpdGVtIGluIG91ciBgaW5kZXhlZERCYCBzdG9yZVxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEByZXR1cm5zIEFuIFJ4SlMgYE9ic2VydmFibGVgIHRvIHdhaXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uXG4gICAqL1xuICBkZWxldGUoa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPHVuZGVmaW5lZD4ge1xuXG4gICAgLyogT3BlbiBhIHRyYW5zYWN0aW9uIGluIHdyaXRlIG1vZGUgKi9cbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbigncmVhZHdyaXRlJykucGlwZShcbiAgICAgIG1lcmdlTWFwKChzdG9yZSkgPT4ge1xuXG4gICAgICAgIC8qIERlbGV0ZXRoZSBpdGVtIGluIHN0b3JlICovXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5kZWxldGUoa2V5KTtcblxuICAgICAgICAvKiBNYW5hZ2Ugc3VjY2VzcyBhbmQgZXJyb3IgZXZlbnRzLCBhbmQgbWFwIHRvIGB0cnVlYCAqL1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RXZlbnRzQW5kTWFwVG8ocmVxdWVzdCwgKCkgPT4gdW5kZWZpbmVkKTtcblxuICAgICAgfSksXG4gICAgICAvKiBUaGUgb2JzZXJ2YWJsZSB3aWxsIGNvbXBsZXRlIGFmdGVyIHRoZSBmaXJzdCB2YWx1ZSAqL1xuICAgICAgZmlyc3QoKSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgaXRlbXMgZnJvbSBvdXIgYGluZGV4ZWREQmAgb2JqZXQgc3RvcmVcbiAgICogQHJldHVybnMgQW4gUnhKUyBgT2JzZXJ2YWJsZWAgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIGNsZWFyKCk6IE9ic2VydmFibGU8dW5kZWZpbmVkPiB7XG5cbiAgICAvKiBPcGVuIGEgdHJhbnNhY3Rpb24gaW4gd3JpdGUgbW9kZSAqL1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnKS5waXBlKFxuICAgICAgbWVyZ2VNYXAoKHN0b3JlKSA9PiB7XG5cbiAgICAgICAgLyogRGVsZXRlIGFsbCBpdGVtcyBpbiBvYmplY3Qgc3RvcmUgKi9cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmNsZWFyKCk7XG5cbiAgICAgICAgLyogTWFuYWdlIHN1Y2Nlc3MgYW5kIGVycm9yIGV2ZW50cywgYW5kIG1hcCB0byBgdHJ1ZWAgKi9cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEV2ZW50c0FuZE1hcFRvKHJlcXVlc3QsICgpID0+IHVuZGVmaW5lZCk7XG5cbiAgICAgIH0pLFxuICAgICAgLyogVGhlIG9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSAqL1xuICAgICAgZmlyc3QoKSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCB0aGUga2V5cyBpbiBvdXIgYGluZGV4ZWREQmAgc3RvcmVcbiAgICogQHJldHVybnMgQW4gUnhKUyBgT2JzZXJ2YWJsZWAgaXRlcmF0aW5nIG9uIGVhY2gga2V5XG4gICAqL1xuICBrZXlzKCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cbiAgICAvKiBPcGVuIGEgdHJhbnNhY3Rpb24gaW4gcmVhZC1vbmx5IG1vZGUgKi9cbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbigncmVhZG9ubHknKS5waXBlKFxuICAgICAgLyogYGZpcnN0KClgIGlzIHVzZWQgYXMgdGhlIGZpbmFsIG9wZXJhdG9yIGluIG90aGVyIG1ldGhvZHMgdG8gY29tcGxldGUgdGhlIGBPYnNlcnZhYmxlYFxuICAgICAgICogKGFzIGl0IGFsbCBzdGFydHMgZnJvbSBhIGBSZXBsYXlTdWJqZWN0YCB3aGljaCBuZXZlciBlbmRzKSxcbiAgICAgICAqIGJ1dCBhcyB0aGlzIG1ldGhvZCBpcyBpdGVyYXRpbmcgb3ZlciBtdWx0aXBsZSB2YWx1ZXMsIGBmaXJzdCgpYCAqKm11c3QqKiBiZSB1c2VkIGhlcmUgKi9cbiAgICAgIGZpcnN0KCksXG4gICAgICBtZXJnZU1hcCgoc3RvcmUpID0+IHtcblxuICAgICAgICAvKiBPcGVuIGEgY3Vyc29yIG9uIHRoZSBzdG9yZVxuICAgICAgICAgKiBgLm9wZW5LZXlDdXJzb3IoKWAgaXMgYmV0dGVyIGZvciBwZXJmb3JtYW5jZSwgYnV0IG9ubHkgYXZhaWxhYmxlIGluIGluZGV4ZWREQiB2MiAobWlzc2luZyBpbiBJRS9FZGdlKVxuICAgICAgICAgKiBBdm9pZCBpc3N1ZXMgbGlrZSBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2lzc3Vlcy82OSAqL1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gKCdvcGVuS2V5Q3Vyc29yJyBpbiBzdG9yZSkgPyBzdG9yZS5vcGVuS2V5Q3Vyc29yKCkgOiAoc3RvcmUgYXMgSURCT2JqZWN0U3RvcmUpLm9wZW5DdXJzb3IoKTtcblxuICAgICAgICAvKiBMaXN0ZW4gdG8gc3VjY2VzcyBldmVudCAqL1xuICAgICAgICBjb25zdCBzdWNjZXNzJCA9IHRoaXMuc3VjY2Vzc0V2ZW50KHJlcXVlc3QpLnBpcGUoXG4gICAgICAgICAgLyogU3RvcCB0aGUgYE9ic2VydmFibGVgIHdoZW4gdGhlIGN1cnNvciBpcyBgbnVsbGAgKi9cbiAgICAgICAgICB0YWtlV2hpbGUoKCkgPT4gKHJlcXVlc3QucmVzdWx0ICE9PSBudWxsKSksXG4gICAgICAgICAgLyogVGhpcyBsaWIgb25seSBhbGxvd3Mgc3RyaW5nIGtleXMsIGJ1dCB1c2VyIGNvdWxkIGhhdmUgYWRkZWQgb3RoZXIgdHlwZXMgb2Yga2V5cyBmcm9tIG91dHNpZGVcbiAgICAgICAgICAgKiBJdCdzIE9LIHRvIGNhc3QgYXMgdGhlIGN1cnNvciBhcyBiZWVuIHRlc3RlZCBpbiB0aGUgcHJldmlvdXMgb3BlcmF0b3IgKi9cbiAgICAgICAgICBtYXAoKCkgPT4gKHJlcXVlc3QucmVzdWx0IGFzIElEQkN1cnNvcikua2V5LnRvU3RyaW5nKCkpLFxuICAgICAgICAgIC8qIEl0ZXJhdGUgb24gdGhlIGN1cnNvciAqL1xuICAgICAgICAgIHRhcCgoKSA9PiB7IChyZXF1ZXN0LnJlc3VsdCBhcyBJREJDdXJzb3IpLmNvbnRpbnVlKCk7IH0pLFxuICAgICAgICApO1xuXG4gICAgICAgIC8qIExpc3RlbiB0byBlcnJvciBldmVudCBhbmQgaWYgc28sIHRocm93IGFuIGVycm9yICovXG4gICAgICAgIGNvbnN0IGVycm9yJCA9IHRoaXMuZXJyb3JFdmVudChyZXF1ZXN0KTtcblxuICAgICAgICAvKiBDaG9vc2UgdGhlIGZpcnN0IGV2ZW50IHRvIG9jY3VyICovXG4gICAgICAgIHJldHVybiByYWNlKFtzdWNjZXNzJCwgZXJyb3IkXSk7XG5cbiAgICAgIH0pLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGtleSBleGlzdHMgaW4gb3VyIGBpbmRleGVkREJgIHN0b3JlXG4gICAqIEByZXR1cm5zIEFuIFJ4SlMgYE9ic2VydmFibGVgIHRlbGxpbmcgaWYgdGhlIGtleSBleGlzdHMgb3Igbm90XG4gICAqL1xuICBoYXMoa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcblxuICAgIC8qIE9wZW4gYSB0cmFuc2FjdGlvbiBpbiByZWFkLW9ubHkgbW9kZSAqL1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKCdyZWFkb25seScpLnBpcGUoXG4gICAgICBtZXJnZU1hcCgoc3RvcmUpID0+IHtcblxuICAgICAgICAvKiBDaGVjayBpZiB0aGUga2V5IGV4aXN0cyBpbiB0aGUgc3RvcmUgKi9cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuZ2V0S2V5UmVxdWVzdChzdG9yZSwga2V5KTtcblxuICAgICAgICAvKiBNYW5hZ2Ugc3VjY2VzcyBhbmQgZXJyb3IgZXZlbnRzLCBhbmQgbWFwIHRvIGEgYm9vbGVhbiBiYXNlZCBvbiB0aGUgZXhpc3RlbmNlIG9mIHRoZSBrZXkgKi9cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEV2ZW50c0FuZE1hcFRvKHJlcXVlc3QsICgpID0+IChyZXF1ZXN0LnJlc3VsdCAhPT0gdW5kZWZpbmVkKSA/IHRydWUgOiBmYWxzZSk7XG5cbiAgICAgIH0pLFxuICAgICAgLyogVGhlIG9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSAqL1xuICAgICAgZmlyc3QoKVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byBgaW5kZXhlZERCYCBhbmQgY3JlYXRlcyB0aGUgb2JqZWN0IHN0b3JlIG9uIGZpcnN0IHRpbWVcbiAgICovXG4gIHByb3RlY3RlZCBjb25uZWN0KCk6IHZvaWQge1xuXG4gICAgbGV0IHJlcXVlc3Q6IElEQk9wZW5EQlJlcXVlc3Q7XG5cbiAgICAvKiBDb25uZWN0IHRvIGBpbmRleGVkREJgXG4gICAgICogV2lsbCBmYWlsIGluIFNhZmFyaSBjcm9zcy1vcmlnaW4gaWZyYW1lc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvaXNzdWVzLzQyfSAqL1xuICAgIHRyeSB7XG5cbiAgICAgIC8qIERvIE5PVCBleHBsaWNpdCBgd2luZG93YCBoZXJlLCBhcyBgaW5kZXhlZERCYCBjb3VsZCBiZSB1c2VkIGZyb20gYSB3ZWIgd29ya2VyIHRvbyAqL1xuICAgICAgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMuZGJOYW1lLCB0aGlzLmRiVmVyc2lvbik7XG5cbiAgICB9wqBjYXRjaCB7XG5cbiAgICAgIHRoaXMuZGF0YWJhc2UuZXJyb3IobmV3IElEQkJyb2tlbkVycm9yKCkpO1xuXG4gICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICAvKiBDcmVhdGUgc3RvcmUgb24gZmlyc3QgY29ubmVjdGlvbiAqL1xuICAgIHRoaXMuY3JlYXRlU3RvcmUocmVxdWVzdCk7XG5cbiAgICAvKiBMaXN0ZW4gdG8gc3VjY2VzcyBhbmQgZXJyb3IgZXZlbnRzIGFuZCBjaG9vc2UgdGhlIGZpcnN0IHRvIG9jY3VyICovXG4gICAgcmFjZShbdGhpcy5zdWNjZXNzRXZlbnQocmVxdWVzdCksIHRoaXMuZXJyb3JFdmVudChyZXF1ZXN0KV0pXG4gICAgICAvKiBUaGUgb2JzZXJ2YWJsZSB3aWxsIGNvbXBsZXRlICovXG4gICAgICAucGlwZShmaXJzdCgpKVxuICAgICAgLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAvKiBSZWdpc3RlciB0aGUgZGF0YWJhc2UgY29ubmVjdGlvbiBpbiB0aGUgYFJlcGxheVN1YmplY3RgIGZvciBmdXJ0aGVyIGFjY2VzcyAqL1xuICAgICAgICAgIHRoaXMuZGF0YWJhc2UubmV4dChyZXF1ZXN0LnJlc3VsdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiAoKSA9PiB7XG4gICAgICAgICAgLyogRmlyZWZveCBwcml2YXRlIG1vZGUgaXNzdWU6IGZhbGxiYWNrIHN0b3JhZ2UgaWYgSW5kZXhlZERiIGNvbm5lY3Rpb24gaXMgZmFpbGluZ1xuICAgICAgICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzgxOTgyfVxuICAgICAgICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9pc3N1ZXMvMjZ9ICovXG4gICAgICAgICAgdGhpcy5kYXRhYmFzZS5lcnJvcihuZXcgSURCQnJva2VuRXJyb3IoKSk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBzdG9yZSBvbiBmaXJzdCB1c2Ugb2YgYGluZGV4ZWREQmBcbiAgICogQHBhcmFtIHJlcXVlc3QgYGluZGV4ZWREQmAgZGF0YWJhc2Ugb3BlbmluZyByZXF1ZXN0XG4gICAqL1xuICBwcm90ZWN0ZWQgY3JlYXRlU3RvcmUocmVxdWVzdDogSURCT3BlbkRCUmVxdWVzdCk6IHZvaWQge1xuXG4gICAgLyogTGlzdGVuIHRvIHRoZSBldmVudCBmaXJlZCBvbiBmaXJzdCBjb25uZWN0aW9uICovXG4gICAgZnJvbUV2ZW50KHJlcXVlc3QsICd1cGdyYWRlbmVlZGVkJylcbiAgICAgIC8qIFRoZSBvYnNlcnZhYmxlIHdpbGwgY29tcGxldGUgKi9cbiAgICAgIC5waXBlKGZpcnN0KCkpXG4gICAgICAuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogKCkgPT4ge1xuXG4gICAgICAgICAgLyogQ2hlY2sgaWYgdGhlIHN0b3JlIGFscmVhZHkgZXhpc3RzLCB0byBhdm9pZCBlcnJvciAqL1xuICAgICAgICAgIGlmICghcmVxdWVzdC5yZXN1bHQub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyh0aGlzLnN0b3JlTmFtZSkpIHtcblxuICAgICAgICAgICAgLyogQ3JlYXRlIHRoZSBvYmplY3Qgc3RvcmUgKi9cbiAgICAgICAgICAgIHJlcXVlc3QucmVzdWx0LmNyZWF0ZU9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9KTtcblxuICB9XG5cbiAgLyoqXG4gICAqIE9wZW4gYW4gYGluZGV4ZWREQmAgdHJhbnNhY3Rpb24gYW5kIGdldCBvdXIgc3RvcmVcbiAgICogQHBhcmFtIG1vZGUgYHJlYWRvbmx5YCBvciBgcmVhZHdyaXRlYFxuICAgKiBAcmV0dXJucyBBbiBgaW5kZXhlZERCYCBzdG9yZSwgd3JhcHBlZCBpbiBhbiBSeEpTIGBPYnNlcnZhYmxlYFxuICAgKi9cbiAgcHJvdGVjdGVkIHRyYW5zYWN0aW9uKG1vZGU6IElEQlRyYW5zYWN0aW9uTW9kZSk6IE9ic2VydmFibGU8SURCT2JqZWN0U3RvcmU+IHtcblxuICAgIC8qIEZyb20gdGhlIGBpbmRleGVkREJgIGNvbm5lY3Rpb24sIG9wZW4gYSB0cmFuc2FjdGlvbiBhbmQgZ2V0IHRoZSBzdG9yZSAqL1xuICAgIHJldHVybiB0aGlzLmRhdGFiYXNlXG4gICAgICAucGlwZShtZXJnZU1hcCgoZGF0YWJhc2UpID0+IHtcblxuICAgICAgICBsZXQgc3RvcmU6IElEQk9iamVjdFN0b3JlO1xuXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICBzdG9yZSA9IGRhdGFiYXNlLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0sIG1vZGUpLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcblxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXG4gICAgICAgICAgICAvKiBUaGUgc3RvcmUgY291bGQgaGF2ZSBiZWVuIGRlbGV0ZWQgZnJvbSBvdXRzaWRlICovXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvciBhcyBET01FeGNlcHRpb24pO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2Yoc3RvcmUpO1xuXG4gICAgICB9KSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gYW4gYGluZGV4ZWREQmAgc3VjY2VzcyBlcnJvciBldmVudFxuICAgKiBAcGFyYW0gcmVxdWVzdCBSZXF1ZXN0IHRvIGxpc3RlblxuICAgKiBAcmV0dXJucyBBbiBSeEpTIGBPYnNlcnZhYmxlYCBsaXN0ZW5pbmcgdG8gdGhlIHN1Y2Nlc3MgZXZlbnRcbiAgICovXG4gIHByb3RlY3RlZCBzdWNjZXNzRXZlbnQocmVxdWVzdDogSURCUmVxdWVzdCk6IE9ic2VydmFibGU8RXZlbnQ+IHtcblxuICAgIHJldHVybiBmcm9tRXZlbnQocmVxdWVzdCwgJ3N1Y2Nlc3MnKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBhbiBgaW5kZXhlZERCYCByZXF1ZXN0IGVycm9yIGV2ZW50XG4gICAqIEBwYXJhbSByZXF1ZXN0IFJlcXVlc3QgdG8gbGlzdGVuXG4gICAqIEByZXR1cm5zIEFuIFJ4SlMgYE9ic2VydmFibGVgIGxpc3RlbmluZyB0byB0aGUgZXJyb3IgZXZlbnQgYW5kIGlmIHNvLCB0aHJvd2luZyBhbiBlcnJvclxuICAgKi9cbiAgcHJvdGVjdGVkIGVycm9yRXZlbnQocmVxdWVzdDogSURCUmVxdWVzdCk6IE9ic2VydmFibGU8bmV2ZXI+IHtcblxuICAgIHJldHVybiBmcm9tRXZlbnQocmVxdWVzdCwgJ2Vycm9yJykucGlwZShtZXJnZU1hcCgoKSA9PiB0aHJvd0Vycm9yKHJlcXVlc3QuZXJyb3IgYXMgRE9NRXhjZXB0aW9uKSkpO1xuXG4gIH1cblxuICAvKipcbiAgICogTGlzdGVuIHRvIGFuIGBpbmRleGVkREJgIHJlcXVlc3Qgc3VjY2VzcyBhbmQgZXJyb3IgZXZlbnQsIGFuZCBtYXAgdG8gdGhlIHdhbnRlZCB2YWx1ZVxuICAgKiBAcGFyYW0gcmVxdWVzdCBSZXF1ZXN0IHRvIGxpc3RlblxuICAgKiBAcGFyYW0gbWFwQ2FsbGJhY2sgQ2FsbGJhY2sgcmV0dXJuaW5nIHRoZSB3YW50ZWQgdmFsdWVcbiAgICogQHJldHVybnMgQW4gUnhKUyBgT2JzZXJ2YWJsZWAgbGlzdGVuaW5nIHRvIHJlcXVlc3QgZXZlbnRzIGFuZCBtYXBwaW5nIHRvIHRoZSB3YW50ZWQgdmFsdWVcbiAgICovXG4gIHByb3RlY3RlZCByZXF1ZXN0RXZlbnRzQW5kTWFwVG88VD4ocmVxdWVzdDogSURCUmVxdWVzdCwgbWFwQ2FsbGJhY2s6ICgpID0+IFQpOiBPYnNlcnZhYmxlPFQ+IHtcblxuICAgIC8qIExpc3RlbiB0byB0aGUgc3VjY2VzcyBldmVudCBhbmQgbWFwIHRvIHRoZSB3YW50ZWQgdmFsdWVcbiAgICAgKiBgbWFwVG8oKWAgbXVzdCBub3QgYmUgdXNlZCBoZXJlIGFzIGl0IHdvdWxkIGV2YWwgYHJlcXVlc3QucmVzdWx0YCB0b28gc29vbiAqL1xuICAgIGNvbnN0IHN1Y2Nlc3MkID0gdGhpcy5zdWNjZXNzRXZlbnQocmVxdWVzdCkucGlwZShtYXAobWFwQ2FsbGJhY2spKTtcblxuICAgIC8qIExpc3RlbiB0byB0aGUgZXJyb3IgZXZlbnQgKi9cbiAgICBjb25zdCBlcnJvciQgPSB0aGlzLmVycm9yRXZlbnQocmVxdWVzdCk7XG5cbiAgICAvKiBDaG9vc2UgdGhlIGZpcnN0IGV2ZW50IHRvIG9jY3VyICovXG4gICAgcmV0dXJuIHJhY2UoW3N1Y2Nlc3MkLCBlcnJvciRdKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBrZXkgZXhpc3RzIGluIHRoZSBzdG9yZVxuICAgKiBAcGFyYW0gc3RvcmUgT2JqZXQgc3RvcmUgb24gd2hpY2ggdG8gcGVyZm9ybSB0aGUgcmVxdWVzdFxuICAgKiBAcGFyYW0ga2V5IEtleSB0byBjaGVja1xuICAgKiBAcmV0dXJucyBBbiBgaW5kZXhlZERCYCByZXF1ZXN0XG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0S2V5UmVxdWVzdChzdG9yZTogSURCT2JqZWN0U3RvcmUsIGtleTogc3RyaW5nKTogSURCUmVxdWVzdCB7XG5cbiAgICAvKiBgZ2V0S2V5KClgIGlzIGJldHRlciBidXQgb25seSBhdmFpbGFibGUgaW4gYGluZGV4ZWREQmAgdjIgKENocm9tZSA+PSA1OCwgbWlzc2luZyBpbiBJRS9FZGdlKS5cbiAgICAgKiBJbiBvbGRlciBicm93c2VycywgdGhlIHZhbHVlIGlzIGNoZWNrZWQgaW5zdGVhZCwgYnV0IGl0IGNvdWxkIGxlYWQgdG8gYW4gZXhjZXB0aW9uXG4gICAgICogaWYgYHVuZGVmaW5lZGAgd2FzIHN0b3JlZCBvdXRzaWRlIG9mIHRoaXMgbGliIChlLmcuIGRpcmVjdGx5IHdpdGggdGhlIG5hdGl2ZSBgaW5kZXhlZERCYCBBUEkpLlxuICAgICAqIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvaXNzdWVzLzY5XG4gICAgICovXG4gICAgcmV0dXJuICgnZ2V0S2V5JyBpbiBzdG9yZSkgPyBzdG9yZS5nZXRLZXkoa2V5KSA6IChzdG9yZSBhcyBJREJPYmplY3RTdG9yZSkuZ2V0KGtleSk7XG5cbiAgfVxuXG59XG4iXX0=