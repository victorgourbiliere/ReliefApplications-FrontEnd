import * as tslib_1 from "tslib";
import { Injectable, Inject } from '@angular/core';
import { Observable, of, throwError, asyncScheduler } from 'rxjs';
import { observeOn } from 'rxjs/operators';
import { SerializationError } from './exceptions';
import { LOCAL_STORAGE_PREFIX, LS_PREFIX } from '../tokens';
import * as i0 from "@angular/core";
import * as i1 from "../tokens";
let LocalStorageDatabase = class LocalStorageDatabase {
    /**
     * Constructor params are provided by Angular (but can also be passed manually in tests)
     * @param prefix Prefix option to avoid collision for multiple apps on the same subdomain or for interoperability
     * @param oldPrefix Prefix option prior to v8 to avoid collision for multiple apps on the same subdomain or for interoperability
     */
    constructor(prefix = '', 
    // tslint:disable-next-line: deprecation
    oldPrefix = '') {
        /* Priority for the new prefix option, otherwise old prefix with separator, or no prefix */
        this.prefix = prefix || (oldPrefix ? `${oldPrefix}_` : '');
    }
    /**
     * Number of items in `localStorage`
     */
    get size() {
        /* Wrap in a RxJS `Observable` to be consistent with other storages */
        return of(localStorage.length);
    }
    /**
     * Gets an item value in `localStorage`
     * @param key The item's key
     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS `Observable`
     */
    get(key) {
        /* Get raw data */
        const unparsedData = localStorage.getItem(this.prefixKey(key));
        let parsedData;
        /* No need to parse if data is `null` or `undefined` */
        if ((unparsedData !== undefined) && (unparsedData !== null)) {
            /* Try to parse */
            try {
                parsedData = JSON.parse(unparsedData);
            }
            catch (error) {
                return throwError(error);
            }
        }
        /* Wrap in a RxJS `Observable` to be consistent with other storages */
        return of(parsedData);
    }
    /**
     * Store an item in `localStorage`
     * @param key The item's key
     * @param data The item's value
     * @returns A RxJS `Observable` to wait the end of the operation
     */
    set(key, data) {
        let serializedData = null;
        /* Check if data can be serialized */
        const dataPrototype = Object.getPrototypeOf(data);
        if ((typeof data === 'object') && (data !== null) && !Array.isArray(data) &&
            !((dataPrototype === Object.prototype) || (dataPrototype === null))) {
            return throwError(new SerializationError());
        }
        /* Try to stringify (can fail on circular references) */
        try {
            serializedData = JSON.stringify(data);
        }
        catch (error) {
            return throwError(error);
        }
        /* Can fail if storage quota is exceeded */
        try {
            localStorage.setItem(this.prefixKey(key), serializedData);
        }
        catch (error) {
            return throwError(error);
        }
        /* Wrap in a RxJS `Observable` to be consistent with other storages */
        return of(undefined);
    }
    /**
     * Deletes an item in `localStorage`
     * @param key The item's key
     * @returns A RxJS `Observable` to wait the end of the operation
     */
    delete(key) {
        localStorage.removeItem(this.prefixKey(key));
        /* Wrap in a RxJS `Observable` to be consistent with other storages */
        return of(undefined);
    }
    /**
     * Deletes all items in `localStorage`
     * @returns A RxJS `Observable` to wait the end of the operation
     */
    clear() {
        localStorage.clear();
        /* Wrap in a RxJS `Observable` to be consistent with other storages */
        return of(undefined);
    }
    /**
     * Get all keys in `localStorage`
     * Note the order of the keys may be inconsistent in Firefox
     * @returns A RxJS `Observable` iterating on keys
     */
    keys() {
        /* Create an `Observable` from keys */
        return new Observable((subscriber) => {
            /* Iteretate over all the indexes */
            for (let index = 0; index < localStorage.length; index += 1) {
                /* Cast as we are sure in this case the key is not `null` */
                subscriber.next(this.getUnprefixedKey(index));
            }
            subscriber.complete();
        }).pipe(
        /* Required to work like other databases which are asynchronous */
        observeOn(asyncScheduler));
    }
    /**
     * Check if a key exists in `localStorage`
     * @param key The item's key
     * @returns A RxJS `Observable` telling if the key exists or not
     */
    has(key) {
        /* Itérate over all indexes in storage */
        for (let index = 0; index < localStorage.length; index += 1) {
            if (key === this.getUnprefixedKey(index)) {
                /* Wrap in a RxJS `Observable` to be consistent with other storages */
                return of(true);
            }
        }
        /* Wrap in a RxJS `Observable` to be consistent with other storages */
        return of(false);
    }
    /**
     * Get an unprefixed key
     * @param index Index of the key
     * @returns The unprefixed key name if exists, `null` otherwise
     */
    getUnprefixedKey(index) {
        /* Get the key in storage: may have a prefix */
        const prefixedKey = localStorage.key(index);
        if (prefixedKey !== null) {
            /* If no prefix, the key is already good, otherwrite strip the prefix */
            return !this.prefix ? prefixedKey : prefixedKey.substr(this.prefix.length);
        }
        return null;
    }
    /**
     * Add the prefix to a key
     * @param key The key name
     * @returns The prefixed key name
     */
    prefixKey(key) {
        return `${this.prefix}${key}`;
    }
};
LocalStorageDatabase.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function LocalStorageDatabase_Factory() { return new LocalStorageDatabase(i0.ɵɵinject(i1.LS_PREFIX), i0.ɵɵinject(i1.LOCAL_STORAGE_PREFIX)); }, token: LocalStorageDatabase, providedIn: "root" });
LocalStorageDatabase = tslib_1.__decorate([
    Injectable({
        providedIn: 'root'
    }),
    tslib_1.__param(0, Inject(LS_PREFIX)),
    tslib_1.__param(1, Inject(LOCAL_STORAGE_PREFIX)),
    tslib_1.__metadata("design:paramtypes", [Object, Object])
], LocalStorageDatabase);
export { LocalStorageDatabase };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9jYWxzdG9yYWdlLWRhdGFiYXNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neC1wd2EvbG9jYWwtc3RvcmFnZS8iLCJzb3VyY2VzIjpbImxpYi9kYXRhYmFzZXMvbG9jYWxzdG9yYWdlLWRhdGFiYXNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBQUUsVUFBVSxFQUFFLEVBQUUsRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2xFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUczQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDbEQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLFNBQVMsRUFBRSxNQUFNLFdBQVcsQ0FBQzs7O0FBSzVELElBQWEsb0JBQW9CLEdBQWpDLE1BQWEsb0JBQW9CO0lBTy9COzs7O09BSUc7SUFDSCxZQUNxQixTQUFTLEVBQUU7SUFDOUIsd0NBQXdDO0lBQ1YsWUFBWSxFQUFFO1FBRzVDLDJGQUEyRjtRQUMzRixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7SUFFN0QsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBSSxJQUFJO1FBRU4sc0VBQXNFO1FBQ3RFLE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUVqQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEdBQUcsQ0FBVSxHQUFXO1FBRXRCLGtCQUFrQjtRQUNsQixNQUFNLFlBQVksR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUUvRCxJQUFJLFVBQXlCLENB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QUssR0FBRyxZQUFZLENBQUMsTUFBTSxFQUFFLEtBQUssSUFBSSxDQUFDLEVBQUU7WUFFM0QsSUFBSSxHQUFHLEtBQUssSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUV4QyxzRUFBc0U7Z0JBQ3RFLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBRWpCO1NBRUY7UUFFRCxzRUFBc0U7UUFDdEUsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7SUFFbkIsQ0FBQztJQUVEOzs7O09BSUc7SUFDTyxnQkFBZ0IsQ0FBQyxLQUFhO1FBRXRDLCtDQUErQztRQUMvQyxNQUFNLFdBQVcsR0FBRyxZQUFZLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRTVDLElBQUksV0FBVyxLQUFLLElBQUksRUFBRTtZQUV4Qix3RUFBd0U7WUFDeEUsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBRTVFO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFFZCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNPLFNBQVMsQ0FBQyxHQUFXO1FBRTdCLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDO0lBRWhDLENBQUM7Q0FFRixDQUFBOztBQWhOWSxvQkFBb0I7SUFIaEMsVUFBVSxDQUFDO1FBQ1YsVUFBVSxFQUFFLE1BQU07S0FDbkIsQ0FBQztJQWNHLG1CQUFBLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQTtJQUVqQixtQkFBQSxNQUFNLENBQUMsb0JBQW9CLENBQUMsQ0FBQTs7R0FmcEIsb0JBQW9CLENBZ05oQztTQWhOWSxvQkFBb0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mLCB0aHJvd0Vycm9yLCBhc3luY1NjaGVkdWxlciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgb2JzZXJ2ZU9uIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBMb2NhbERhdGFiYXNlIH0gZnJvbSAnLi9sb2NhbC1kYXRhYmFzZSc7XG5pbXBvcnQgeyBTZXJpYWxpemF0aW9uRXJyb3IgfSBmcm9tICcuL2V4Y2VwdGlvbnMnO1xuaW1wb3J0IHsgTE9DQUxfU1RPUkFHRV9QUkVGSVgsIExTX1BSRUZJWCB9IGZyb20gJy4uL3Rva2Vucyc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIExvY2FsU3RvcmFnZURhdGFiYXNlIGltcGxlbWVudHMgTG9jYWxEYXRhYmFzZSB7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIHVzZXIgcHJlZml4IHRvIGF2b2lkIGNvbGxpc2lvbiBmb3IgbXVsdGlwbGUgYXBwcyBvbiB0aGUgc2FtZSBzdWJkb21haW5cbiAgICovXG4gIHJlYWRvbmx5IHByZWZpeDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBwYXJhbXMgYXJlIHByb3ZpZGVkIGJ5IEFuZ3VsYXIgKGJ1dCBjYW4gYWxzbyBiZSBwYXNzZWQgbWFudWFsbHkgaW4gdGVzdHMpXG4gICAqIEBwYXJhbSBwcmVmaXggUHJlZml4IG9wdGlvbiB0byBhdm9pZCBjb2xsaXNpb24gZm9yIG11bHRpcGxlIGFwcHMgb24gdGhlIHNhbWUgc3ViZG9tYWluIG9yIGZvciBpbnRlcm9wZXJhYmlsaXR5XG4gICAqIEBwYXJhbSBvbGRQcmVmaXggUHJlZml4IG9wdGlvbiBwcmlvciB0byB2OCB0byBhdm9pZCBjb2xsaXNpb24gZm9yIG11bHRpcGxlIGFwcHMgb24gdGhlIHNhbWUgc3ViZG9tYWluIG9yIGZvciBpbnRlcm9wZXJhYmlsaXR5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KExTX1BSRUZJWCkgcHJlZml4ID0gJycsXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBkZXByZWNhdGlvblxuICAgIEBJbmplY3QoTE9DQUxfU1RPUkFHRV9QUkVGSVgpIG9sZFByZWZpeCA9ICcnLFxuICApIHtcblxuICAgIC8qIFByaW9yaXR5IGZvciB0aGUgbmV3IHByZWZpeCBvcHRpb24sIG90aGVyd2lzZSBvbGQgcHJlZml4IHdpdGggc2VwYXJhdG9yLCBvciBubyBwcmVmaXggKi9cbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeCB8fCAob2xkUHJlZml4ID8gYCR7b2xkUHJlZml4fV9gIDogJycpO1xuXG4gIH1cblxuICAvKipcbiAgICogTnVtYmVyIG9mIGl0ZW1zIGluIGBsb2NhbFN0b3JhZ2VgXG4gICAqL1xuICBnZXQgc2l6ZSgpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuXG4gICAgLyogV3JhcCBpbiBhIFJ4SlMgYE9ic2VydmFibGVgIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBvdGhlciBzdG9yYWdlcyAqL1xuICAgIHJldHVybiBvZihsb2NhbFN0b3JhZ2UubGVuZ3RoKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gaXRlbSB2YWx1ZSBpbiBgbG9jYWxTdG9yYWdlYFxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEByZXR1cm5zIFRoZSBpdGVtJ3MgdmFsdWUgaWYgdGhlIGtleSBleGlzdHMsIGB1bmRlZmluZWRgIG90aGVyd2lzZSwgd3JhcHBlZCBpbiBhIFJ4SlMgYE9ic2VydmFibGVgXG4gICAqL1xuICBnZXQ8VCA9IGFueT4oa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+IHtcblxuICAgIC8qIEdldCByYXcgZGF0YSAqL1xuICAgIGNvbnN0IHVucGFyc2VkRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMucHJlZml4S2V5KGtleSkpO1xuXG4gICAgbGV0IHBhcnNlZERhdGE6IFQgfCB1bmRlZmluZWQ7XG5cbiAgICAvKiBObyBuZWVkIHRvIHBhcnNlIGlmIGRhdGEgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgICovXG4gICAgaWYgKCh1bnBhcnNlZERhdGEgIT09IHVuZGVmaW5lZCkgJiYgKHVucGFyc2VkRGF0YSAhPT0gbnVsbCkpIHtcblxuICAgICAgLyogVHJ5IHRvIHBhcnNlICovXG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWREYXRhID0gSlNPTi5wYXJzZSh1bnBhcnNlZERhdGEpIGFzIFQ7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvciBhcyBTeW50YXhFcnJvcik7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvKiBXcmFwIGluIGEgUnhKUyBgT2JzZXJ2YWJsZWAgdG8gYmUgY29uc2lzdGVudCB3aXRoIG90aGVyIHN0b3JhZ2VzICovXG4gICAgcmV0dXJuIG9mKHBhcnNlZERhdGEpO1xuXG4gIH1cblxuICAvKipcbiAgICogU3RvcmUgYW4gaXRlbSBpbiBgbG9jYWxTdG9yYWdlYFxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEBwYXJhbSBkYXRhIFRoZSBpdGVtJ3MgdmFsdWVcbiAgICogQHJldHVybnMgQSBSeEpTIGBPYnNlcnZhYmxlYCB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgKi9cbiAgc2V0KGtleTogc3RyaW5nLCBkYXRhOiBhbnkpOiBPYnNlcnZhYmxlPHVuZGVmaW5lZD4ge1xuXG4gICAgbGV0IHNlcmlhbGl6ZWREYXRhOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcblxuICAgIC8qIENoZWNrIGlmIGRhdGEgY2FuIGJlIHNlcmlhbGl6ZWQgKi9cbiAgICBjb25zdCBkYXRhUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGRhdGEpO1xuICAgIGlmICgodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSAmJiAoZGF0YSAhPT0gbnVsbCkgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSkgJiZcbiAgICAhKChkYXRhUHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlKSB8fCAoZGF0YVByb3RvdHlwZSA9PT0gbnVsbCkpKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgU2VyaWFsaXphdGlvbkVycm9yKCkpO1xuICAgIH1cblxuICAgIC8qIFRyeSB0byBzdHJpbmdpZnkgKGNhbiBmYWlsIG9uIGNpcmN1bGFyIHJlZmVyZW5jZXMpICovXG4gICAgdHJ5IHtcbiAgICAgIHNlcmlhbGl6ZWREYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycm9yIGFzIFR5cGVFcnJvcik7XG4gICAgfVxuXG4gICAgLyogQ2FuIGZhaWwgaWYgc3RvcmFnZSBxdW90YSBpcyBleGNlZWRlZCAqL1xuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnByZWZpeEtleShrZXkpLCBzZXJpYWxpemVkRGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycm9yIGFzIERPTUV4Y2VwdGlvbik7XG4gICAgfVxuXG4gICAgLyogV3JhcCBpbiBhIFJ4SlMgYE9ic2VydmFibGVgIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBvdGhlciBzdG9yYWdlcyAqL1xuICAgIHJldHVybiBvZih1bmRlZmluZWQpO1xuXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhbiBpdGVtIGluIGBsb2NhbFN0b3JhZ2VgXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHJldHVybnMgQSBSeEpTIGBPYnNlcnZhYmxlYCB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgKi9cbiAgZGVsZXRlKGtleTogc3RyaW5nKTogT2JzZXJ2YWJsZTx1bmRlZmluZWQ+IHtcblxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMucHJlZml4S2V5KGtleSkpO1xuXG4gICAgLyogV3JhcCBpbiBhIFJ4SlMgYE9ic2VydmFibGVgIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBvdGhlciBzdG9yYWdlcyAqL1xuICAgIHJldHVybiBvZih1bmRlZmluZWQpO1xuXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgaXRlbXMgaW4gYGxvY2FsU3RvcmFnZWBcbiAgICogQHJldHVybnMgQSBSeEpTIGBPYnNlcnZhYmxlYCB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgKi9cbiAgY2xlYXIoKTogT2JzZXJ2YWJsZTx1bmRlZmluZWQ+IHtcblxuICAgIGxvY2FsU3RvcmFnZS5jbGVhcigpO1xuXG4gICAgLyogV3JhcCBpbiBhIFJ4SlMgYE9ic2VydmFibGVgIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBvdGhlciBzdG9yYWdlcyAqL1xuICAgIHJldHVybiBvZih1bmRlZmluZWQpO1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBrZXlzIGluIGBsb2NhbFN0b3JhZ2VgXG4gICAqIE5vdGUgdGhlIG9yZGVyIG9mIHRoZSBrZXlzIG1heSBiZSBpbmNvbnNpc3RlbnQgaW4gRmlyZWZveFxuICAgKiBAcmV0dXJucyBBIFJ4SlMgYE9ic2VydmFibGVgIGl0ZXJhdGluZyBvbiBrZXlzXG4gICAqL1xuICBrZXlzKCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cbiAgICAvKiBDcmVhdGUgYW4gYE9ic2VydmFibGVgIGZyb20ga2V5cyAqL1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZTxzdHJpbmc+KChzdWJzY3JpYmVyKSA9PiB7XG5cbiAgICAgIC8qIEl0ZXJldGF0ZSBvdmVyIGFsbCB0aGUgaW5kZXhlcyAqL1xuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGluZGV4ICs9IDEpIHtcblxuICAgICAgICAvKiBDYXN0IGFzIHdlIGFyZSBzdXJlIGluIHRoaXMgY2FzZSB0aGUga2V5IGlzIG5vdCBgbnVsbGAgKi9cbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KHRoaXMuZ2V0VW5wcmVmaXhlZEtleShpbmRleCkgYXMgc3RyaW5nKTtcblxuICAgICAgfVxuXG4gICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG5cbiAgICB9KS5waXBlKFxuICAgICAgLyogUmVxdWlyZWQgdG8gd29yayBsaWtlIG90aGVyIGRhdGFiYXNlcyB3aGljaCBhcmUgYXN5bmNocm9ub3VzICovXG4gICAgICBvYnNlcnZlT24oYXN5bmNTY2hlZHVsZXIpLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGtleSBleGlzdHMgaW4gYGxvY2FsU3RvcmFnZWBcbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgKiBAcmV0dXJucyBBIFJ4SlMgYE9ic2VydmFibGVgIHRlbGxpbmcgaWYgdGhlIGtleSBleGlzdHMgb3Igbm90XG4gICAqL1xuICBoYXMoa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcblxuICAgIC8qIEl0w6lyYXRlIG92ZXIgYWxsIGluZGV4ZXMgaW4gc3RvcmFnZSAqL1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpbmRleCArPSAxKSB7XG5cbiAgICAgIGlmIChrZXkgPT09IHRoaXMuZ2V0VW5wcmVmaXhlZEtleShpbmRleCkpwqB7XG5cbiAgICAgICAgLyogV3JhcCBpbiBhIFJ4SlMgYE9ic2VydmFibGVgIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBvdGhlciBzdG9yYWdlcyAqL1xuICAgICAgICByZXR1cm4gb2YodHJ1ZSk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8qIFdyYXAgaW4gYSBSeEpTIGBPYnNlcnZhYmxlYCB0byBiZSBjb25zaXN0ZW50IHdpdGggb3RoZXIgc3RvcmFnZXMgKi9cbiAgICByZXR1cm4gb2YoZmFsc2UpO1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIHVucHJlZml4ZWQga2V5XG4gICAqIEBwYXJhbSBpbmRleCBJbmRleCBvZiB0aGUga2V5XG4gICAqIEByZXR1cm5zIFRoZSB1bnByZWZpeGVkIGtleSBuYW1lIGlmIGV4aXN0cywgYG51bGxgIG90aGVyd2lzZVxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFVucHJlZml4ZWRLZXkoaW5kZXg6IG51bWJlcik6IHN0cmluZyB8IG51bGwge1xuXG4gICAgLyogR2V0IHRoZSBrZXkgaW4gc3RvcmFnZTogbWF5IGhhdmUgYSBwcmVmaXggKi9cbiAgICBjb25zdCBwcmVmaXhlZEtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaW5kZXgpO1xuXG4gICAgaWYgKHByZWZpeGVkS2V5ICE9PSBudWxsKSB7XG5cbiAgICAgIC8qIElmIG5vIHByZWZpeCwgdGhlIGtleSBpcyBhbHJlYWR5IGdvb2QsIG90aGVyd3JpdGUgc3RyaXAgdGhlIHByZWZpeCAqL1xuICAgICAgcmV0dXJuICF0aGlzLnByZWZpeCA/IHByZWZpeGVkS2V5IDogcHJlZml4ZWRLZXkuc3Vic3RyKHRoaXMucHJlZml4Lmxlbmd0aCk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcblxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgcHJlZml4IHRvIGEga2V5XG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBuYW1lXG4gICAqIEByZXR1cm5zIFRoZSBwcmVmaXhlZCBrZXkgbmFtZVxuICAgKi9cbiAgcHJvdGVjdGVkIHByZWZpeEtleShrZXk6IHN0cmluZyk6IHN0cmluZyB7XG5cbiAgICByZXR1cm4gYCR7dGhpcy5wcmVmaXh9JHtrZXl9YDtcblxuICB9XG5cbn1cbiJdfQ==